
##--------------------------------------------------------------------##
##--------------------------------------------------------------------##
##--                        TRANSITION MAPPINGS                     --##
##
##-- Broadly speaking, the idea here is to define, in a 
##-- generic way, transitions from one state in one dimension
##-- to another state in the same dimension.
##
##-- This file defines and handle four major types of quantities
##-- 1) **transitions** - formulas (in the form of character strings, expressions, or 'calls' generated by expr)
##--    that tell the model how to calculate the rate of transition,
##-- 2) **model.quantities** - also formulas that tell the model how to calculate specific quantities
##--    that are not directly used for transitions between states (eg susceptibility or new infection proportions)
##-- 3) **model.elements** - the specific quantities that go into the formulas above.
##--    These have to be registered so the model knows how to get values for them
##-- 4) **model.element.combos** - formulas that combine multiple transition elements (for convenience)
##
##--------------------------------------------------------------------##
##--------------------------------------------------------------------##



##-----------------------------------------------------##
##--                      SCHEMA                     --##
##                                                     ##
##-- Define the overall structure of what dimensions --##
##-- are allowed to have transition mappings         --##
##-----------------------------------------------------##

TRANSITION.MAPPING.SUBGROUPS = c('hiv.negative', 'hiv.positive')
MODEL.QUANTITY.MAPPING.SUBGROUPS = c(TRANSITION.MAPPING.SUBGROUPS, c('all','general'))

#-- Model quantity schema --#
create.model.quantity.schema <- function(name,
                                         subgroups)
{
    if (!is.character(name) || length(name) != 1 || is.na(name) || name=='')
        stop("'name' must be a single character value")
    
    if (!is.character(subgroups) || length(subgroups)==0 ||
        length(setdiff(subgroups, MODEL.QUANTITY.MAPPING.SUBGROUPS))>0)
        stop(paste0("subgroup must be a character with at one or more elements that are a subset of: ",
                    paste0("'", MODEL.QUANTITY.MAPPING.SUBGROUPS, "'", collapse=', ')))
    
    rv = list(
        name=name,
        subgroups=subgroups
    )
}

REQUIRED.MODEL.QUANTITY.SCHEMA = list(
    #-- Transmission --#
    create.model.quantity.schema("sexual.susceptibility",
                                 subgroups='hiv.negative'),
    create.model.quantity.schema("idu.susceptibility",
                                 subgroups='hiv.negative'),
    
    create.model.quantity.schema("sexual.transmissibility",
                                 subgroups='hiv.positive'),
    create.model.quantity.schema("idu.transmissibility",
                                 subgroups='hiv.positive'),
    
    create.model.quantity.schema("sexual.contact",
                                 subgroups='full.contact'),
    create.model.quantity.schema("idu.contact",
                                 subgroups='contact.without.risk'),
    
    create.model.quantity.schema("new.infection.proportions",
                                 subgroups='all'),
    
    #-- Mortality --#
    create.model.quantity.schema("hiv.mortality",
                                 subgroups='hiv.positive'),
    create.model.quantity.schema("general.mortality.hiv.negative",
                                 subgroups='hiv.negative'),
    create.model.quantity.schema("general.mortality.hiv.positive",
                                 subgroups='hiv.positive'),
    
    #-- Initial Population --#
    create.model.quantity.schema("initial.population.hiv.negative",
                                 subgroups='hiv.negative'),
    create.model.quantity.schema("initial.population.hiv.positive",
                                 subgroups='hiv.positive'),
    
    #-- Fertility/Births --#
    create.model.quantity.schema("fertility.hiv.negative",
                                 subgroups='hiv.negative'),
    create.model.quantity.schema("fertility.hiv.positive",
                                 subgroups='hiv.positive'),
    create.model.quantity.schema("birth.proportions",
                                 subgroups='birth.proportions'),
    
    #-- Aging --#
    create.model.quantity.schema("aging.hiv.negative",
                                 subgroups='hiv.negative'),
    create.model.quantity.schema("aging.hiv.positive",
                                 subgroups='hiv.positive')
)
names(REQUIRED.MODEL.QUANTITY.SCHEMA) = sapply(REQUIRED.MODEL.QUANTITY.SCHEMA, function(sch){sch$name})


##------------------------------------------------------##
##--            TRANSITION ELEMENTS SCALES            --##
##                                                      ##
##--  The scales on which transition elements operate --##
##------------------------------------------------------##

MODEL.ELEMENT.SCALES = c('rate',
                             'ratio',
                             'proportion', #an alias for proportion.leaving
                             'proportion.leaving',
                             'proportion.staying',
                             'time')


MODEL.ELEMENT.RAMP.SCALES = c('identity','log','exp')

# values should be a list
convert.model.element.scale <- function(values,
                                            convert.from.scale,
                                            convert.to.scale)
{
    check.model.element.scale(convert.from.scale)
    check.model.element.scale(convert.to.scale)
    
    need.to.unlist = !is.list(values)
    if (need.to.unlist)
        values = list(values)
    
    if (convert.from.scale==convert.to.scale)
    {}
    else if (convert.from.scale=='ratio')
        stop("Cannot convert from scale 'ratio' (to '", convert.to.scale, "')")
    else if (convert.to.scale=='ratio')
        stop("Cannot convert to scale 'ratio' (from '", convert.from.scale, "')")
    else if (convert.from.scale=='rate')
    {
        if (convert.to.scale=='proportion' || convert.to.scale=='proportion.leaving')
            values = lapply(values, function(r){1-exp(-r)})
        else if (convert.to.scale=='proportion.staying')
            values = lapply(values, function(r){exp(-r)})
        else if (convert.to.scale=='time')
            values = lapply(values, function(r){1/r})
        else
            stop(paste0("Internal Error: Have not defined conversions from '", convert.from.scale, "' to '", convert.to.scale, "'"))
    }
    else if (convert.from.scale=='proportion' || convert.from.scale=='proportion.leaving')
    {
        if (convert.to.scale=='rate')
            values = lapply(values, function(p){-log(1-p)})
        else if (convert.to.scale=='proportion.staying')
            values = lapply(values, function(p){1-p})
        else if (convert.to.scale=='time')
            values = lapply(values, function(p){-1/log(1-p)})
        else
            stop(paste0("Internal Error: Have not defined conversions from '", convert.from.scale, "' to '", convert.to.scale, "'"))
    }
    else if (convert.from.scale=='proportion.staying')
    {
        if (convert.to.scale=='rate')
            values = lapply(values, function(p){-log(p)})
        else if (convert.to.scale=='proportion' || convert.to.scale=='proportion.leaving')
            values = lapply(values, function(p){1-p})
        else if (convert.to.scale=='time')
            values = lapply(values, function(p){-1/log(p)})
        else
            stop(paste0("Internal Error: Have not defined conversions from '", convert.from.scale, "' to '", convert.to.scale, "'"))
    }
    else if (convert.from.scale=='time')
    {
        if (convert.to.scale=='rate')
            values = lapply(values, function(t){1/t})
        else if (convert.to.scale=='proportion' || convert.to.scale=='proportion.leaving')
            values = lapply(values, function(t){1-exp(-1/t)})
        else if (convert.to.scale=='proportion.staying')
            values = lapply(values, function(t){exp(-1/t)})
        else
            stop(paste0("Internal Error: Have not defined conversions from '", convert.from.scale, "' to '", convert.to.scale, "'"))
    }
    else
        stop(paste0("Internal Error: Have not defined conversions from '", convert.from.scale, "'"))
    
    # Return
    if (need.to.unlist)
        values[[1]]
    else
        values
}


check.model.element.scale <- function(scale,
                                      varname.for.error='scale',
                                      error.prefix='')
{
    if (!is.character(scale) || length(scale)!=1 || is.na(scale))
        stop(paste0(error.prefix, "'", varname.for.error, "' must be a non-NA character scalar"))
    
    if (all(scale != MODEL.ELEMENT.SCALES))
        stop(paste0(error.prefix, "'", varname.for.error, "' must be one of the following: ",
                    paste0("'", MODEL.ELEMENT.SCALES, "'", collapse=', ')))
}




##----------------------------------------------------##
##--                  MODEL ELEMENTS                --##
##                                                    ##
##--   The elements that get combined/manipulated   --##
##--   to produce transition rates                  --##
##----------------------------------------------------##

#'@param name The name of the transition element
#'@param scale The scale to which this model.element evaluates (eg, is it a proportion, a rate, a time?)
#'@param value A numeric value that serves as the value for this element if it is not otherwise specified. If NULL, then a value must be specified either by a background model or in subsequent code
#'@param get.value.function An alternative to passing value directly, if the value needs to be different by location. This should be a function that takes arguments location, specification, and ... 
#'
#'@param model An object of class 'model' that produces the background values for this element. Pass NULL if no background model is to be used, or if it is to be obtained by get.model.function
#'@param get.model.function An alternative to passing background model directly, if the background model needs to be different by location. This should be a function that takes arguments location, specification, and ... 
#'@param model.scale The scale of values produced by the background model
#'@param ... Arguments to be passed to either get.model.function or 
#'
#'@param ramp.scale If the ramp operates on a different scale than the element evaluates to, specified here
#'@param ramp.times The (default) times at which to ramp up
#'@param ramp.multipliers The (default) multipliers for ramp times
#'@param ramp.interpolate.scales The scale at which to interpolate values for the ramp
#'
create.model.element <- function(name,
                                 scale,
                                 value=NULL,
                                 get.value.function=NULL,
                                 
                                 model=NULL,
                                 get.model.function=NULL,
                                 model.scale=scale,
                                 model.from.time=NULL,
                                 model.to.time=Inf,
                                 ...,
                                 
                                 ramp.scale=scale,
                                 ramp.times=numeric(),
                                 ramp.multipliers=numeric(),
                                 ramp.interpolate.scales='identity',
                                 
                                 taper.scale=scale,
                                 taper.times=numeric(),
                                 taper.multipliers=numeric(),
                                 taper.interpolate.scales='identity')
{
    #-- Check Name --#
    if (!is.character(name) || length(name)!=1 || is.na(name))
        stop("'name' must be a non-na character scalar")
    
    error.prefix = paste0("For model.element, '", name, "', ")
    
    #-- Check Scales --#
    check.model.element.scale(scale, 'scale', error.prefix = error.prefix)
    check.model.element.scale(model.scale, 'model.scale', error.prefix = error.prefix)
    check.model.element.scale(ramp.scale, 'ramp.scale', error.prefix = error.prefix)
    check.model.element.scale(taper.scale, 'taper.scale', error.prefix = error.prefix)

    #-- Must pass either value or model, or a function to get one --#
    if (!is.null(value) || !is.null(get.value.function)) # We are specifying value, not model
    {
        if (!is.null(model) || !is.null(get.model.function))
            stop(paste0(error.prefix,
                        "you cannot specify BOTH a value and a model (or functions to get value/model) - you must specify one or the other"))
        else if (!is.null(value)) # Using value, not get.value.function
        {
            if (!is.null(get.value.function))
                stop(paste0(error.prefix, "you cannot specity BOTH a value and get.value.function - one or the other must be NULL"))
            
            if (!is.numeric(value) || length(value)==0 || any(is.na(value)))
                stop(paste0(error.prefix,
                            "'value' must be a non-empty, numeric object with no NA values"))
        }
        else # Using get.value.function
        {
            if (!is.function(get.value.function))
                stop(paste0(error.prefix, "if specified, 'get.model.function' must be a function that takes as arguments location, specification, and ..."))

            orig.get.value.function = get.value.function   
            get.value.function = function(location, specification){
                orig.get.value.function(location=location, specification=specification, ...)
            }            
        }
    }
    else # We are specifying model, not value
    {
        if (!is.null(model))
        {
            if (!is.null(get.model.function))
                stop(paste0(error.prefix, "you cannot specity BOTH a model and get.model.function - one or the other must be NULL"))
            
            if (!is(model, 'model'))
                stop(paste0(error.prefix, "'model' must be an object of class 'model'"))
        }
        else if (!is.null(get.model.function))
        {
            if (!is.function(get.model.function))
                stop(paste0(error.prefix, "if specified, 'get.model.function' must be a function that takes as arguments location, specification, and ..."))
            
            orig.get.model.function = get.model.function   
            get.model.function = function(location, specification){
                orig.get.model.function(location=location, specification=specification, ...)
            }
        }
        else
            stop(paste0(error.prefix, "either 'value' or 'model' (or a function to get value or model) must be specified"))
    }
    

    # check model times
    if (!is.null(model) || !is.null(get.model.function))
    {
        if (is.null(model.from.time))
            stop(paste0(error.prefix, 
                        "'model.from.time' must be set if a model is specified (through the 'model' or 'get.model.function' arguments)"))
        
        if (!is.numeric(model.from.time) || length(model.from.time)!=1 || is.na(model.from.time))
            stop(paste0(error.prefix, "'model.from.time' must be a single, non-NA, numeric value"))
        
        current.year = as.numeric(format(Sys.Date(), "%Y"))
        if (model.from.time < MIN.MODEL.FROM.YEAR || model.from.time > current.year)
            stop(paste0(error.prefix, "'model.from.time' (", model.from.time, ") should be between ",
                        MIN.MODEL.FROM.YEAR,
                        " and ", current.year))
        
        
        
        if (is.null(model.to.time))
            stop(paste0(error.prefix, 
                        "'model.to.time' must be set if a model is specified (through the 'model' or 'get.model.function' arguments)"))
        
        if (!is.numeric(model.to.time) || length(model.to.time)!=1 || is.na(model.to.time))
            stop(paste0(error.prefix, "'model.to.time' must be a single, non-NA, numeric value"))

        if (model.to.time < model.from.time)
            stop(paste0(error.prefix, "'model.to.time' (",
                        model.to.time,
                        ") should be greater than 'model.from.time' (",
                        model.from.time, ")"))
    }
    else
    {
        model.from.time = model.to.time = NULL
    }
    

    #-- Check ramp --#
    if (length(ramp.times)>0)
    {
        if (is.null(model) && is.null(get.model.function))
            stop(paste0(error.prefix, "a ramp can only be set up if a model is specified (through the 'model' or 'get.model.function' arguments)"))
        
        if (length(ramp.multipliers)==0)
            stop(paste0(error.prefix, "ramp.times has been set, but ramp.multipliers is empty"))
        if (length(ramp.interpolate.scales)==0)
            stop(paste0(error.prefix, "ramp.times has been set, but ramp.interpolate.scales is empty"))
        
        if (!is.numeric(ramp.times))
            stop(paste0(error.prefix, "ramp.times must be a numeric vector"))
        if (!all(ramp.times==sort(ramp.times)))
            stop(paste0(error.prefix, "ramp.times must be in increasing order"))
        
        if (!is.numeric(ramp.multipliers))
            stop(paste0(error.prefix, "ramp.times must be a numeric vector"))
        if (!is.character(ramp.interpolate.scales))
            stop(paste0(error.prefix, "ramp.interpolate.scales must be a character vector"))
        invalid.scales = setdiff(ramp.interpolate.scales, MODEL.ELEMENT.RAMP.SCALES)
        if (length(invalid.scales)>0)
            stop(paste0(error.prefix, "invalid value(s) for ramp.interpolate.scales (",
                        paste0("'", invalid.scales, "'", collapse=', '),
                        ") - values must be one of: ",
                        paste0("'", MODEL.ELEMENT.RAMP.SCALES, "'", collapse=', ')))
        
        if (length(ramp.interpolate.scales)==1)
            ramp.interpolate.scales = rep(ramp.interpolate.scales, length(ramp.times))
        if (length(ramp.times) != length(ramp.interpolate.scales))
            stop(paste0(error.prefix, "ramp.times and ramp.interpolate.scales must have the same length OR ramp.interpolate.scales must be a single value"))
        
        if (length(ramp.times) != length(ramp.multipliers))
            stop(paste0(error.prefix, "ramp.times and ramp.multipliers must have the same length"))
        
        if (is.null(names(ramp.times)))
        {
            if (!is.null(names(ramp.multipliers)))
                names(ramp.times) = names(ramp.multipliers)
        }
        else
        {
            if (is.null(names(ramp.multipliers)))
                names(ramp.multipliers) = names(ramp.times)
            else if (!all(names(ramp.multipliers)==names(ramp.times)))
                stop(paste0(error.prefix, "ramp.multipliers and ramp.times must have the same names"))
        }
        
        if (!is.null(names(ramp.interpolate.scales)) && 
            !all(names(ramp.interpolate.scales)==names(ramp.multipliers)))
            stop(paste0(error.prefix, "ramp.interpolate.scales must have the same names as ramp.times and/or ramp.multipliers"))
        
        names(ramp.interpolate.scales) = names(ramp.multipliers)
    }
    else if (length(ramp.multipliers)>0)
        stop(paste0(error.prefix, "ramp.multipliers has been set, but ramp.times is empty"))
    else
        ramp.multipliers = ramp.times = NULL

    
    #-- Check taper --#
    if (length(taper.times)>0)
    {
        if (is.null(model) && is.null(get.model.function))
            stop(paste0(error.prefix, "a taper can only be set up if a model is specified (through the 'model' or 'get.model.function' arguments)"))
        
        if (length(taper.multipliers)==0)
            stop(paste0(error.prefix, "taper.times has been set, but taper.multipliers is empty"))
        if (length(taper.interpolate.scales)==0)
            stop(paste0(error.prefix, "taper.times has been set, but taper.interpolate.scales is empty"))
        
        if (!is.numeric(taper.times))
            stop(paste0(error.prefix, "taper.times must be a numeric vector"))
        if (!all(taper.times==sort(taper.times)))
            stop(paste0(error.prefix, "taper.times must be in increasing order"))
        
        if (!is.numeric(taper.multipliers))
            stop(paste0(error.prefix, "taper.times must be a numeric vector"))
        if (!is.character(taper.interpolate.scales))
            stop(paste0(error.prefix, "taper.interpolate.scales must be a character vector"))
        invalid.scales = setdiff(taper.interpolate.scales, MODEL.ELEMENT.RAMP.SCALES)
        if (length(invalid.scales)>0)
            stop(paste0(error.prefix, "invalid value(s) for taper.interpolate.scales (",
                        paste0("'", invalid.scales, "'", collapse=', '),
                        ") - values must be one of: ",
                        paste0("'", MODEL.ELEMENT.RAMP.SCALES, "'", collapse=', ')))
        
        if (length(taper.interpolate.scales)==1)
            taper.interpolate.scales = rep(taper.interpolate.scales, length(taper.times))
        if (length(taper.times) != length(taper.interpolate.scales))
            stop(paste0(error.prefix, "taper.times and taper.interpolate.scales must have the same length OR taper.interpolate.scales must be a single value"))
        
        if (length(taper.times) != length(taper.multipliers))
            stop(paste0(error.prefix, "taper.times and taper.multipliers must have the same length"))
        
        if (is.null(names(taper.times)))
        {
            if (!is.null(names(taper.multipliers)))
                names(taper.times) = names(taper.multipliers)
        }
        else
        {
            if (is.null(names(taper.multipliers)))
                names(taper.multipliers) = names(taper.times)
            else if (!all(names(taper.multipliers)==names(taper.times)))
                stop(paste0(error.prefix, "taper.multipliers and taper.times must have the same names"))
        }
        
        if (!is.null(names(taper.interpolate.scales)) && 
            !all(names(taper.interpolate.scales)==names(taper.multipliers)))
            stop(paste0(error.prefix, "taper.interpolate.scales must have the same names as taper.times and/or taper.multipliers"))
        
        names(taper.interpolate.scales) = names(taper.multipliers)
    }
    else if (length(taper.multipliers)>0)
        stop(paste0(error.prefix, "taper.multipliers has been set, but taper.times is empty"))
    else
        taper.multipliers = taper.times = NULL
    
   
    #-- Make the object and return --#
    
    rv = list(
        name=name,
        scale=scale,
        
        value=value,
        get.value.function=get.value.function,
        
        model=model,
        get.model.function = get.model.function,
        model.scale=model.scale,
        model.from.time=model.from.time,
        model.to.time=model.to.time,
        
        ramp.scale=ramp.scale,
        ramp.times = ramp.times,
        ramp.multipliers = ramp.multipliers,
        ramp.interpolate.scales=ramp.interpolate.scales,
        
        taper.scale=taper.scale,
        taper.times = taper.times,
        taper.multipliers = taper.multipliers,
        taper.interpolate.scales=taper.interpolate.scales
    )
    
    class(rv) = 'model.element'
    rv
}

MIN.MODEL.FROM.YEAR = 1970

rename.model.element <- function(model.element, new.name, mapping.depth)
{
    model.element$original.name = model.element$name
    model.element$mapping.depth = mapping.depth
    model.element$name = new.name
    
    model.element
}


# Actually calculates the values of the ramp multipliers at desired time points
# visible to setup code
calculate.ramp.multipliers.and.times <- function(ramp.times,
                                                 ramp.multipliers,
                                                 ramp.scales,
                                                 first.non.ramp.time,
                                                 check.for.errors=T)
{
    do.calculate.taper.or.ramp(ramp.times=ramp.times,
                               ramp.multipliers=ramp.multipliers,
                               ramp.scales=ramp.scales,
                               non.ramp.time=first.non.ramp.time,
                               is.ramp=T,
                               check.for.errors=check.for.errors)
}

# Actually calculates the values of the taper multipliers at desired time points
# visible to setup code
calculate.taper.multipliers.and.times <- function(taper.times,
                                                  taper.multipliers,
                                                  taper.scales,
                                                  last.non.taper.time,
                                                  check.for.errors=T)
{

    do.calculate.taper.or.ramp(ramp.times=taper.times,
                               ramp.multipliers=taper.multipliers,
                               ramp.scales=taper.scales,
                               non.ramp.time=last.non.taper.time,
                               is.ramp=F,
                               check.for.errors=check.for.errors)
}

# internal to transition.mapping
do.calculate.taper.or.ramp <- function(ramp.times,
                                       ramp.multipliers,
                                       ramp.scales,
                                       non.ramp.time,
                                       is.ramp,
                                       check.for.errors=T)
{
    # Check for errors
    if (is.ramp)
        ramp.or.taper = 'ramp'
    else
        ramp.or.taper = 'taper'
    
    if (check.for.errors)
    {
        if (is.ramp && non.ramp.time < max(ramp.times))
            stop("ramp.times must all be PRIOR to first.non,ramp time")
        if (!is.ramp && non.ramp.time > max(ramp.times))
            stop("taper.times must all be PRIOR to first.non.taper time")
        
        if (any(is.na(ramp.multipliers)))
            stop(paste0("NA values not allowed when calculating ramp multipliers"))
    
        o = order(ramp.times)
    
        ramp.times = ramp.times[o]
        ramp.multipliers = ramp.multipliers[o]
        ramp.scales = ramp.scales[o]
    }
    
    # If this is a taper, invert everything
    if (!is.ramp)
    {
        ramp.times = rev(-ramp.times)
        ramp.multipliers = rev(ramp.mulipliers)
        ramp.scales = rev(ramp.scales)
        non.ramp.time = -non.ramp.time
    }
    
    # Calculate
    times = c(ramp.times, non.ramp.time)
    multipliers = c(ramp.multipliers, 1)
    
    n.segments = length(ramp.times)
    
    rv = list()
    multipliers = unlist(sapply(1:n.segments, function(i){
        interpolate.times = times[i]:times[i+1]
        interpolate.times = interpolate.times[-length(interpolate.times)]
        
        if (ramp.scales[i]=='log')
            exp(interpolate.parameters(values=log(multipliers[i:(i+1)]),
                                       value.times=times[i:(i+1)],
                                       desired.times = interpolate.times,
                                       return.list = F))
        else if (ramp.scales[i]=='exp')
            log(interpolate.parameters(values=exp(multipliers[i:(i+1)]),
                                       value.times=times[i:(i+1)],
                                       desired.times = interpolate.times,
                                       return.list = F))
        else #identity
            multipliers[i]
    }))
    
    times = unlist(sapply(1:n.segments, function(i){
        if (ramp.scales[i]=='identity')
            times[i]
        else #not identity
        {
            rv = times[i]:times[i+1]
            rv[-length(rv)]
        }
    }))
    
    # If this is a taper, invert everything back
    if (!is.ramp)
    {
        times = rev(-times)
        multipliers = rev(multipliers)
    }
    
    # Package up and return
    list(
        multipliers=multipliers,
        times=times
    )
}

model.element.needs.setup <- function(model.element)
{
    # in the create.model.element code, we have disallowed ramps if there is no model
    # If this ever changes, then would need setup for a ramp even if model is missing
    model.element.has.model(model.element)
}

model.element.has.model <- function(model.element)
{
    if (!is(model.element, 'model.element'))
        stop("model.element must be an object of class 'model.element'")
    
    !is.null(model.element$model) || !is.null(model.element$get.model.function)
}

get.model.element.model <- function(model.element, location, specification)
{
    if (!is(model.element, 'model.element'))
        stop("model.element must be an object of class 'model.element'")
    
    if (!is.null(model.element$model))
        model.element$model
    else if (!is.null(model.element$get.model.function))
    {
        rv = model.element$get.model.function(location=location, specification=specification)
        if (!is(rv, 'model'))
            stop(paste0("The 'get.model.function' for model.element '",
                        model.element$name, "' should return an object of class 'model'"))
        
        do.check.model.dimensions(model.element, model=model)
        
        rv
    }
    else
        NULL
}

get.model.element.value <- function(model.element, location, specification)
{
    if (!is(model.element, 'model.element'))
        stop("model.element must be an object of class 'model.element'")
    
    if (!is.null(model.element$value))
        model.element$value
    else if (!is.null(model.element$get.value.function))
    {
        rv = model.element$get.model.value(location=location, specification=specification)
        if (!is.numeric(rv) || length(rv)==0 || any(is.na(rv)))
            stop(paste0("The 'get.model.value' for model.element '",
                        model.element$name, "' must return a non-empty, numeric object with no NA values"))
        
        if (!value.fits.into.dim.names(value=rv, dim.names=model.element$dim.names))
            stop(paste0("The 'get.model.value' for model.element '",
                        model.element$name,
                        "' returned a value whose dimensions do not fit into the expected dimensions for the element"))
        rv
    }
    else
        NULL
}


##----------------------------##
##-- MODEL QUANTITY OBJECTS --##
##----------------------------##

MODEL.QUANTITY.TYPES = c('general','transition')

create.model.quantity <- function(name,
                                  type,
                                  subtype, #used by dimensions types to denote the dimension
                                  value,
                                  subgroups,
                                  dimension.aliases)
{
    # Check name
    if (!is.character(name) || length(name) != 1 || is.na(name) || name=='')
        stop("'name' must be a single, non-NA, non-empty character value")
    
    # Check type
    if (!is.character(type) || length(type) != 1 || is.na(type) || type=='')
        stop("'type' must be a single, non-NA, non-empty character value")
    
    if (all(type != MODEL.QUANTITY.TYPES))
        stop(paste0("Invalid model quantity type '", type,
                    "'. Type must be one of ",
                    paste0("'", MODEL.QUANTITY.TYPES, "'", collapse=', ')))
    
    # Check sub.type
    if (is.null(subtype) || (length(subtype)==1 && is.na(subtype)))
        subtype = as.character(NA)
    else if (!is.character(subtype) || length(subtype) != 1)
        stop("'subtype' must be a single character value")
    
    # Check subgroups
    if (length(subgroups)==0)
        subgroups = NULL
    else
    {
        if (!is.character(subgroups) || any(is.na(subgroups)))
            stop("'subgroups' must be a non-NA character vector")
        invalid.subgroups = setdiff(subgroups, MODEL.QUANTITY.MAPPING.SUBGROUPS)
        if (length(invalid.subgroups)>0)
            stop(paste0("Invalid subgroup(s) for model quantity '",
                        name, "': ",
                        paste0("'", invalid.subgroups, "'", collapse=', '),
                        ". Subgroups must be a subset of: ",
                        paste0("'", MODEL.QUANTITY.MAPPING.SUBGROUPS, "'", collapse=', ')))
    }
    
    # Check dimension.aliases
    if (length(dimension.aliases)==0)
        dimension.aliases = reversed.aliases = character()
    else
    {
        if (!is.character(dimension.aliases) || 
             is.null(names(dimension.aliases)) ||
             any(is.na(names(dimension.aliases))) ||
             any(names(dimension.aliases)=='') ||
             any(is.na(dimension.aliases)) ||
             any(dimension.aliases==''))
            stop("If 'dimension.aliases' is not empty, it must be a non-NA, named character vector with non-empty names")
    
        tabled.aliases = table(dimension.aliases)
        if (max(tabled.aliases)>1)
            stop(paste0("dimensions cannot appear more than once in 'aliases' (",
                        paste0("'", names(tabled.aliases)[tabled.aliases>1], "'", collapse=', ')))
        
        tabled.alias.names = table(names(dimension.aliases))
        if (max(tabled.alias.names)>1)
            stop(paste0("dimensions cannot appear more than once in the names of 'aliases' (",
                        paste0("'", names(tabled.alias.names)[tabled.alias.names>1], "'", collapse=', ')))
        
        reversed.aliases = names(dimension.aliases)
        names(reversed.aliases) = as.character(dimension.aliases)
    }    
    
    
    # Make the first component
    first.component = create.model.quantity.component(name = name,
                                                      value = value,
                                                      applies.to = NULL,
                                                      allow.empty.applies.to = T)
    
    rv = list(
        name = name,
        type = type,
        subtype = subtype,
        subgroups = subgroups,
        dimension.aliases = dimension.aliases,
        reversed.aliases = reversed.aliases,
        components = list(),
        depends.on = character()
    )
    
    class(rv) = 'model.quantity'
    
    rv = add.model.quantity.component(rv,
                                      component = first.component,
                                      component.name = paste0(name, "_all"))
    
    
    rv
}

add.model.quantity.component <- function(model.quantity,
                                         component,
                                         component.name)
{
    if (!is(model.quantity, 'model.quantity'))
        stop("'model.quantity' must be an object of class 'model.quantity'")
    if (!is(component, 'model.quantity.component'))
        stop("'component' must be an object of class 'model.quantity.component'")
    if (!is.character(component.name) || length(component.name)!=1 || is.na(component.name) || component.name=='')
        stop("'component.name' must be a single, non-NA, non-empty character value'")
    
    to.add = list(component)
    names(to.add) = component.name
    model.quantity$components = c(model.quantity$components,
                                  to.add)
    
    calculate.model.quantity.depends.on(model.quantity)
}

calculate.model.quantity.depends.on <- function(model.quantity)
{
    if (!is(model.quantity, 'model.quantity'))
        stop("'model.quantity' must be an object of class 'model.quantity'")
    
    model.quantity$depends.on = unique(as.character(unlist(
        sapply(model.quantity$components, function(comp){
            comp$depends.on
        }))))
    
    model.quantity
}

create.model.quantity.component <- function(name,
                                            value,
                                            applies.to=NULL,
                                            allow.empty.applies.to=T)
{
    # Check name
    if (!is.character(name) || length(name) != 1 || is.na(name) || name=='')
        stop("'name' must be a single, non-NA, non-empty character value")
    
   
    # Check applies.to
    if (allow.empty.applies.to)
    {
        if (length(applies.to)==0)
            applies.to = NULL
        else
        {
            if (!is.list(applies.to) || is.null(names(applies.to)) || any(is.na(names(applies.to))) || any(names(applies.to)==''))
                stop("applies.to must be a named list, with no empty or NA names")
            
            if (any(sapply(applies.to, function(elem){
                ( !is.integer(elem) && !is.character(elem) && !is.logical(elem) ) ||
                    !is.null(dim(elem)) ||
                    length(elem) == 0 ||
                    any(is.na(elem))
            })))
                stop("The elements of applies.to must be either integer, logical, or character vectors that are non-empty with no NA values")
        }
    }
    else if (length(applies.to)==0)
    {
        stop("'applies.to' must be a non-empty named list")
    }
    
    
    # Make the return value and return
    rv = list(
        name = name,
        applies.to = applies.to
    )
    
    class(rv) = c('model.quantity.component')
    
    rv = set.model.quantity.component.value(rv, value = value)
    
    rv
}

set.model.quantity.component.value <- function(model.quantity.component,
                                                  value)
{
    if (!is(model.quantity.component, 'model.quantity.component'))
        stop("'component' must be an object of class 'model.quantity.component'")
    
    # Check/Prepare value (it should end up of class 'call' or 'numeric')    
    if (is.character(value))
    {
        if (length(value) != 1 || is.na(value) || value=='')
            stop("If 'value' is a character, it must be a single, non-NA, non-empty character value")
        
        value = parse(text=value)[[1]]
    }
    else if (is.numeric(value))
    {
        if (length(value)==0)
            stop("'value' cannot be empty")
        if (any(is.na(value)))
            stop("'value' cannot contain NA values")
        if (length(value) != 1 && is.null(dim(value)))
            stop("If 'value' is a numeric vector, then it must be of length 1")
    }
    else if (is.expression(value))
    {
        if (length(expression)!=1)
            stop("If 'value' is an expression, it must be of length 1")
        
        value = value[[1]]
    }
    
    if (!is.call(value) && !is.name(value) && !is.numeric(value))
        stop("'value' must be either a character value, a numeric value, an expression, a name, or a call generated by expr()")
    
    model.quantity.component$value = value
    model.quantity.component$depends.on = all.vars(model.quantity.component$value)
    
    model.quantity.component
}

rename.model.quantity <- function(model.quantity, new.name, mapping.depth)
{
    model.quantity$original.name = model.quantity$name
    model.quantity$mapping.depth = mapping.depth
    model.quantity$name = new.name
    
    for (i in 1:length(model.quantity$components))
    {
        model.quantity$components[[i]]$original.name = model.quantity$original.name
        model.quantity$components[[i]]$mapping.depth = mapping.depth
        model.quantity$components[[i]]$name = new.name
    }
    
    model.quantity
}

##---------------------------------------------------------##
##---------------------------------------------------------##
##--                  TRANSITION MAPPING                 --##
##                                                         ##
##-- A general data structure that describes transitions --##
##-- for each dimension and their component elements     --##
##---------------------------------------------------------##
##---------------------------------------------------------##

##---------------------------------------------------##
##--         TRANSITION MAPPING CONSTRUCTORS       --##
##-- (and functions to modify an existing mapping) --##
##---------------------------------------------------##

create.transition.mapping <- function(version, 
                                      parent.mapping=NULL,
                                      exclude.parent.model.quantity.or.element.names=character(),
                                      exclude.parent.transitions.for.dimension=character())
{
    if (!is.null(parent.mapping) && !is(parent.mapping, 'transition.mapping'))
        stop("'parent.mapping' must be a transition.mapping object")
    if (!is.null(parent.mapping) && parent.mapping$finalized)
        stop("'parent.mapping' must be an UNfinalized transition.mapping object")
    
    
    do.not.inherit.model.quantity.or.element.names = 
        unique(c(exclude.parent.model.quantity.or.element.names,
                 unlist(get.dimension.transition.quantity.name(exclude.parent.transitions.for.dimension,
                                                     TRANSITION.MAPPING.SUBGROUPS))))
    
    do.create.transition.mapping(version = version,
                                 
                                 model.quantities = list(),
                                 model.elements = list(),
                                 
                                 parent.mapping = parent.mapping,
                                 do.not.inherit.model.quantity.or.element.names = do.not.inherit.model.quantity.or.element.names,
                                 
                                 finalized=F
    )
}

do.create.transition.mapping <- function(version,
                                         model.quantities,
                                         model.elements,
                                         parent.mapping,
                                         do.not.inherit.model.quantity.or.element.names,
                                         finalized)
{
    rv = list(version = version,
              
              model.quantities = model.quantities,
              model.elements = model.elements,
              
              parent.mapping = parent.mapping,
              do.not.inherit.model.quantity.or.element.names = do.not.inherit.model.quantity.or.element.names,
              
              finalized=finalized
    )
    
    class(rv) = 'transition.mapping'
    
    rv
}

##---------------------------------------------##
##-- GETTER FUNCTIONS for TRANSITION MAPPING --##
##---------------------------------------------##

# public facing towards setup functions
get.model.quantity <- function(transition.mapping, quantity.name,
                               throw.error.if.missing=F)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("'transition.mapping' must be a transition.mapping object")
    if (!is.character(quantity.name) || length(quantity.name) != 1 || is.na(quantity.name))
        stop("'quantity.name' must be a single, non-NA, character value")
    
    rv = get.model.quantity.and.mapping.depth(transition.mapping,
                                              quantity.name=quantity.name)$quantity
    
    if (is.null(rv))
    {
        if (throw.error.if.missing)
            stop(paste0("No model quantity named '",
                        quantity.name, "' has been registered with this transition.mapping",
                        ifelse(!transition.mapping$finalized && !is.null(transition.mapping$parent.mapping),
                               " or any of its ancestors",
                               "")))
    }

    rv
}


# public facing towards setup functions
get.model.element <- function(transition.mapping, element.name,
                               throw.error.if.missing=F)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("'transition.mapping' must be a transition.mapping object")
    if (!is.character(element.name) || length(element.name) != 1 || is.na(element.name))
        stop("'element.name' must be a single, non-NA, character value")
    
    rv = get.model.element.and.mapping.depth(transition.mapping,
                                             element.name=element.name)$element
    
    if (is.null(rv))
    {
        if (throw.error.if.missing)
            stop(paste0("No model element named '",
                        element.name, "' has been registered with this transition.mapping",
                        ifelse(!transition.mapping$finalized && !is.null(transition.mapping$parent.mapping),
                               " or any of its ancestors",
                               "")))
    }
    
    rv
}

get.model.element.names <- function(transition.mapping)
{
    get.ancestor.mapping.element.names(transition.mapping, include.this.names = T)
}

get.model.quantity.names <- function(transition.mapping)
{
    get.ancestor.mapping.quantity.names.names(transition.mapping, include.this.names = T)
}

get.transition.model.quantity.names <- function(transition.mapping)
{
    quantity.names = get.model.quantity.names(transition.mapping)
    mask = sapply(quantity.names, function(name){
        quantity = get.model.quantity(transition.mapping, quantity.name=quantity.name, throw.error.if.missing = T)
        quantity$type == 'transition'
    })
    quantity.names[mask]
}

get.dimension.for.transition.model.quantity <- function(transition.mapping, quantity.name)
{
    quantity = get.model.quantity(transition.mapping, quantity.name=quantity.name, throw.error.if.missing = T)
    if (!quantity$type=='transition')
        stop(paste0("model.quantity '", quantity.name, "' does not represent a transition"))
    
    quantity$subtype
}

get.model.quantity.subgroups <- function(transition.mapping, quantity.name)
{
    quantity = get.model.quantity(transition.mapping, quantity.name=quantity.name, throw.error.if.missing = T)
    quantity$subgroups
}

##-------------------------------------------------------------------------##
##--            REGISTER FUNCTIONS for TRANSITION MAPPING                --##
##-- (to register model quantities, transitions and transition elements) --##
##-------------------------------------------------------------------------##


#'@param value A value specifying how to calculate the value to be applied. It can be either
#'             (1) a character scalar with the name of a value
#'             (2) a call generated by expr() or an expression generated by expression()
register.transition <- function(transition.mapping,
                                dimension,
                                from.state,
                                to.state,
                                value,
                                subgroups,
                                overwrite=F)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("transition.mapping must be an object of class 'transition.mapping'")
    
    # Check dimension
    if (!is.character(dimension) || length(dimension)!=1 || is.na(dimension))
        stop("dimension must be a non-NA, single character value")

    # Check subgroups
    if (!is.character(subgroups) || length(subgroups)==0 || any(is.na(subgroups)))
        stop("subgroups must be a non-NA, non-empty character vector")
    
    invalid.subgroups = setdiff(subgroups, TRANSITION.MAPPING.SUBGROUPS)
    if (length(invalid.subgroups)>0)
        stop(paste0("'", invalid.subgroups, "' is not a valid subgroup for transitions"))
    
    # Check from and to
    check.from.to.value(from.state, "from")
    check.from.to.value(to.state, "to")
    
    # Set up a model quantity
    transition.name = get.specific.transition.name(from=from.state, to=to.state, subgroups=subgroups)
    transition.mapping = do.register.model.quantity(transition.mapping,
                                                    name = transition.name,
                                                    type = 'general',
                                                    subtype = NA,
                                                    value = value,
                                                    subgroups = NULL,
                                                    dimension.aliases = NULL,
                                                    overwrite=overwrite)
    
    for (subgroup in subgroups)
    {
        # Under the hood, a transition is incorporated into a model.quantity for 
        # transitions for the whole dimension as a model quantity component
        # Set up the model quantity if not already registered, and then add a component to it
        quantity.name = get.dimension.transition.quantity.name(dimension, subgroup)
        
        if (is.null(transition.mapping$model.quantities[[quantity.name]]))
        {
            dimension.aliases = dimension
            names(dimension.aliases) = paste0(dimension, '.from')
            
            transition.mapping = do.register.model.quantity(transition.mapping,
                                                            name=quantity.name,
                                                            type = 'transition',
                                                            subtype = dimension,
                                                            value = 0,
                                                            subgroups = subgroups,
                                                            dimension.aliases = dimension.aliases,
                                                            overwrite=F)
        }
        
        applies.to = list(from.state, to.state)
        names(applies.to) = c(paste0(dimension, '.from'), paste0(dimension, '.to'))
        
        transition.mapping = register.model.quantity.subset(transition.mapping,
                                                               quantity.name=quantity.name,
                                                               value=transition.name,
                                                               applies.to=applies.to,
                                                               overwrite=overwrite)
    }
    
    transition.mapping
}


#'@param transition.mapping The transition.mapping object
#'@param name The name of the model quanitity. Cannot overlap with names of model.elements
#'@param value 
#'@param overwrite If FALSE, will throw an error if this call attempts to replace a previously registered model.quantity or subset of a model.quantity
#'@export
register.model.quantity <- function(transition.mapping,
                                    name,
                                    value,
                                    overwrite=F)
{
    if (any(names(REQUIRED.MODEL.QUANTITY.SCHEMA)==name))
        subgroups = REQUIRED.MODEL.QUANTITY.SCHEMA[[name]]$subgroups
    else
        subgroups = NULL
    
    check.model.quantity.name(quantity.name = name)
    
    transition.mapping = do.register.model.quantity(transition.mapping,
                                                    name=name,
                                                    value = value,
                                                    type='general',
                                                    subtype = NA,
                                                    subgroups = subgroups,
                                                    dimension.aliases = NULL,
                                                    overwrite=overwrite)
    
    # Return
    transition.mapping
}

RESERVED.MODEL.QUANTITY.PREFIXES = c(
    'super',
    'transition',
    'this'
)

check.model.quantity.name <- function(quantity.name)
{
    
    if (!is.character(quantity.name) || length(quantity.name) != 1 || is.na(quantity.name) || quantity.name=='')
        stop("'quantity.name' must be a single, non-NA, non-empty character value")
    
    
    matches.reserved = sapply(RESERVED.MODEL.QUANTITY.PREFIXES, function(reserved){
        tolower(substr(quantity.name, 1, nchar(reserved)))==reserved
    })
    
    if (any(matches.reserved))
        stop("Invalid model.quantity name '",
             quantity.name,
             "'. Model quantity names cannot begin with '",
             RESERVED.MODEL.QUANTITY.PREFIXES[matches.reserved])
}

do.register.model.quantity <- function(transition.mapping,
                                       name,
                                       type,
                                       subtype,
                                       value,
                                       subgroups,
                                       dimension.aliases,
                                       overwrite=F)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("transition.mapping must be an object of class 'transition.mapping'")
    
    quantity = create.model.quantity(name = name,
                                     value = value,
                                     type = type,
                                     subtype = subtype,
                                     subgroups = subgroups,
                                     dimension.aliases = dimension.aliases)
    
    # Check for name clashes with transition elements
    if (any(names(transition.mapping$model.elements)==quantity$name))
        stop(paste0("The name '", quantity$name, "' is already in use for a model.element"))
    
    # Check for name clashes with transition elements in ancestor mappings
    if (any(get.ancestor.mapping.element.names(transition.mapping, include.this.names = F)==quantity$name))
        stop(paste0("The name '", quantity$name, "' is already in use for a model.element in an ancestor transition.mapping"))

    # Check for model.quantity with the same name
    if (!overwrite && any(names(transition.mapping$model.quantities)==quantity$name))
        stop(paste0("A model quantity with the name '", quantity$name, "' has already been registered."))
    
    # Add to the transition manager
    transition.mapping$model.quantities[[quantity$name]] = quantity

    # Return
    transition.mapping
}



#'@param name The name of the model.quanitity to which this subset pertains. Cannot overlap with names of model.elements
#'@param value The expression for deriving the value to this component of the model quantity
#'@param applies.to A named list defining what subset of the dimensions of the model quantity this applies to. The names of the list should be names of the dimensions (eg 'continuum'), and the elements of the list should be character, numeric, or logical vectors subsetting the array along that dimension

register.model.quantity.subset <- function(transition.mapping,
                                               quantity.name,
                                               value,
                                               applies.to,
                                               overwrite=F)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("transition.mapping must be an object of class 'transition.mapping'")
    
    # Pull the parent model quantity
    quantity = transition.mapping$model.quantities[[quantity.name]]
    if (is.null(quantity))
        stop(paste0("No model quantity with name '", quantity.name, 
                    "' has been registered. You must register the quantity before you can register components of it."))

    # Create the model quantity component
    mqc = create.model.quantity.component(name=quantity$name,
                                          value=value,
                                          applies.to=applies.to,
                                          allow.empty.applies.to = F)

    # Check for duplicates - clear if needed   
    #check if any of the applies.to.dimensions overlap
    # (the first component applies to the whole quantity, by definition, and does not overlap)
    
    if (length(quantity$components)==1)
        overlapping.applies.to.mask = F
    else
        overlapping.applies.to.mask = c(F, sapply(quantity$components[-1], function(comp){
            if (dimensions.overlap(comp$applies.to, mqc$applies.to))
            {
                if (!overwrite)
                {
                    if (quantity$type=='transition')
                        stop(paste0("Cannot register transition for '", 
                                    names(comp$applies.to)[1], 
                                    "' from ",
                                    paste0("'", comp$applies.to[[1]], "'", collapse=', '), 
                                    " to ",
                                    paste0("'", comp$applies.to[[2]], "'", collapse=', '),
                                    " - a transition applying to an overlapping set of those dimensions has already been registered"))
                    else
                        stop(paste0("Cannot register component for model quantity '", quantity$name, 
                                    "' applying to dimension(s) ", 
                                    paste0("'", names(quantity$applies.to), "'", collapse=', '),
                                    " - a model quantity component applying to an overlapping set of those dimensions has already been registered"))
                }
                else
                    T
            }
            else
                F
        }))
    
    transition.mapping$model.quantities[[mqc$name]]$components = quantity$components[!overlapping.applies.to.mask]

    # Add and return
    if (is.null(mqc$applies.to))
        comp.name = paste0(mqc$name, '_all')
    else
        comp.name = paste0(mqc$name, "_", 
                               paste0(sapply(names(mqc$applies.to), function(app){
                                   paste0(app, "-",
                                          paste0(mqc$applies.to[[app]], collapse=','))
                               }), collapse='_'))
    
    transition.mapping$model.quantities[[mqc$name]] =
        add.model.quantity.component(model.quantity = transition.mapping$model.quantities[[mqc$name]],
                                     component = mqc,
                                     component.name = comp.name)

    transition.mapping
}


#'@param name The name of the transition element
#'@param scale The scale to which this model.element evaluates (eg, is it a proportion, a rate, a time?)
#'@param value A numeric value that serves as the value for this element if it is not otherwise specified. If NULL, then a value must be specified either by a background model or in subsequent code
#'@param get.value.function An alternative to passing value directly, if the value needs to be different by location. This should be a function that takes arguments location, specification, and ... 
#'
#'@param model An object of class 'model' that produces the background values for this element. Pass NULL if no background model is to be used, or if it is to be obtained by get.model.function
#'@param get.model.function An alternative to passing background model directly, if the background model needs to be different by location. This should be a function that takes arguments location, specification, and ... 
#'@param model.scale The scale of values produced by the background model
#'@param ... Arguments to be passed to either get.model.function or 
#'
#'@param ramp.scale If the ramp operates on a different scale than the element evaluates to, specified here
#'@param ramp.times The (default) times at which to ramp up
#'@param ramp.multipliers The (default) multipliers for ramp times
#'@param ramp.interpolate.scales The scale at which to interpolate values for the ramp
#'
register.model.element <- function(transition.mapping,
                                   
                                   name,
                                   scale,
                                   value=NULL,
                                   get.value.function=NULL,
                                   
                                   model=NULL,
                                   get.model.function=NULL,
                                   model.scale=scale,
                                   model.from.time=NULL,
                                   model.to.time=Inf,
                                   ...,
                                   
                                   ramp.scale=scale,
                                   ramp.times=numeric(),
                                   ramp.multipliers=numeric(),
                                   ramp.interpolate.scales='identity',
                                   
                                   taper.scale=scale,
                                   taper.times=numeric(),
                                   taper.multipliers=numeric(),
                                   taper.interpolate.scales=numeric()
)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("transition.mapping must be an object of class 'transition.mapping'")
    
    element = create.model.element(name=name,
                                   scale=scale,
                                   value=value,
                                   get.value.function=get.value.function,
                                   
                                   model=model,
                                   get.model.function=get.model.function,
                                   model.scale=model.scale,
                                   model.from.time=model.from.time,
                                   model.to.time=model.to.time,
                                   ...,
                                   
                                   ramp.scale=ramp.scale,
                                   ramp.times=ramp.times,
                                   ramp.multipliers=ramp.multipliers,
                                   ramp.interpolate.scales=ramp.interpolate.scales,
                                   
                                   taper.scale=taper.scale,
                                   taper.times=taper.times,
                                   taper.multipliers=taper.multipliers,
                                   taper.interpolate.scales=taper.interpolate.scales)
    
    if (any(names(transition.mapping$model.elements)==name))
        stop(paste0("A model.element with name '", name, '" has already been registered.'))
    
    if (any(names(transition.mapping$model.quantities)==name))
        stop(paste0("A model.quantity with name '", name, '" has already been registered.'))
    
    if (any(get.ancestor.mapping.quantity.names(transition.mapping, include.this.names = F)==name))
        stop(paste0("A model.quantity with name '", name, '" has already been registered in an ancestor transition.mapping.'))
    
    transition.mapping$model.elements[[name]] = element
    
    transition.mapping
}


##---------------------------------------------------------##
##-- RECURSIVELY REDUCING (SIMPLIFYING) MODEL QUANTITIES --##
##---------------------------------------------------------##


# reduces the expression ('call') for the model quantity to strip out any sub-model.quantities 
# that are only model.elements (ie, recursively cuts out reducible quantities)
# 
# Changes the transition.mapping to have reduced quantities, and returns the updated mapping
# 
# Assumes that circular references are not present
reduce.model.quantity <- function(transition.mapping,
                                  quantity.name,
                                  force.recalculate=F)
{
    if (!is(transition.mapping, 'transition.mapping'))
        stop("transition.mapping must be an object of class 'transition.mapping'")
    
    quantity = transition.mapping$model.quantities[[quantity.name]]
    if (is.null(quantity))
        stop(paste0("No model quantity with name '", get.original.name(quantity), 
                    "' has been registered."))
    
    if (!force.recalculate && !is.null(quantity$reducible))
        return (transition.mapping)
    
    # reduce the components
    for (i in 1:length(quantity$components))
        transition.mapping = reduce.model.quantity.component(transition.mapping,
                                                             quantity.name = quantity.name,
                                                             component.index = i,
                                                             force.recalculate = force.recalculate)
    # re-pull the quantity with reduced components
    quantity = transition.mapping$model.quantities[[quantity.name]]
    
    # Figure out if we are reducible
    # A model quantity is reducible iff
    # - it has only one component with NULL applies.to 
    is.reducible = length(quantity$components)==1 &&
        is.null(quantity$components[[1]]$applies.to)
    
    transition.mapping$model.quantities[[quantity.name]]$is.reducible = is.reducible
    
    # Update depends on 
    transition.mapping$model.quantities[[quantity.name]] = calculate.model.quantity.depends.on(transition.mapping$model.quantities[[quantity.name]])
    
    # Return the updated transition mapping
    transition.mapping
}

# Changes the transition.mapping to have reduced quantities, and returns the updated mapping
reduce.model.quantity.component <- function(transition.mapping,
                                            quantity.name,
                                            component.index,
                                            force.recalculate=F)
{
    # Not going to check arguments, since we presume a well-formed call from reduce.model.quantity
    
    quantity = transition.mapping$model.quantities[[quantity.name]]
    
    comp = quantity$components[[component.index]]
        
    dependencies.are.elements = is.model.element.name(transition.mapping, comp$depends.on)
    dependencies.are.quantities = is.model.quantity.name(transition.mapping, comp$depends.on)
    
    invalid.dependencies = comp$depends.on[!dependencies.are.elements & !dependencies.are.quantities]
    if (length(invalid.dependencies)>0)
        stop(paste0("Cannot reduce the ", get.ordinal(component.index),
                    " of model.quantity '", get.original.name(quantity), 
                    " - the following have not been defined as model.elements or model.quantities: ",
                    paste0("'", invalid.dependencies, "'", collapse=', ')))
    
    # We only need to reduce if any of the depends.on are model.quantities
    if (any(dependencies.are.quantities))
    {
        dependent.on.quantity.names = comp$depends.on[dependencies.are.quantities]
        
        for (sub.name in dependent.on.quantity.names)
            transition.mapping = reduce.model.quantity(transition.mapping,
                                                       quantity.name = sub.name,
                                                       force.recalculate = force.recalculate)
        
        reducible.dependent.on = sapply(dependent.on.quantity.names, function(dep.on){
            transition.mapping$model.quantities[[dep.on]]$is.reducible
        })
        
        if (any(reducible.dependent.on))
        {
            reducible.dependent.on.values = lapply(dependent.on.quantity.names[reducible.dependent.on], function(dep.on){
                # a model quantity is reducible only if it has only one component - so we refer to just the first component
                transition.mapping$model.quantities[[dep.on]]$components[[1]]$value 
            })
            names(reducible.dependent.on.values) = dependent.on.quantity.names[reducible.dependent.on]
            
            new.value = do.call(substitute,
                                list(expr=comp$value,
                                     env=reducible.dependent.on.values))
            
            
            transition.mapping$model.quantities[[quantity.name]]$components[[component.index]] = 
                set.model.quantity.component.value(comp, value = new.value)
        }
    }
    
    # Return
    transition.mapping
}




##----------------------##
##-- RESOLVING VALUES --##        
##----------------------##

resolve.model.quantity.component <- function(comp, bindings)
{
    if (!is(comp, 'model.quantity.component'))
        stop("'comp' must be an object of class model.quantity.component")
    
    if (!is.list(bindings) || is.null(names(bindings)))
        stop("'bindings' must be a named list")
    
    missing.depends.on = setdiff(comp$depends.on, names(bindings))
    if (length(missing.depends.on)>0)
        stop(paste0("The following element(s)/quantities are not contained in bindings: ",
                    paste0("'", missing.depends.on, "'", collapse=', '),
                    ". Cannot resolve this model.quantity.component."))
    
    if (is.numeric(combo$value))
        combo$value
    else #it's a 'call' (expression)
        eval(combo$value, envir=bindings)
}


##-------------------------------------##
##-- FINALIZE THE TRANSITION MANAGER --##
##-- (using a JHEEM specification object) --##
##-------------------------------------##

finalize.transmission.mapping <- function(transition.mapping,
                                          specification,
                                          verbose=F)
{
    if (verbose)
        print("Starting finalization of transition mapping")
    
    #-- Make sure required model quantities are present --#
    if (verbose)
        print("Checking for missing required quantities")
    missing.required.quantities.mask = sapply(REQUIRED.MODEL.QUANTITY.SCHEMA, function(sch){
        is.null(get.model.quantity(transition.mapping, quantity.name=sch$name))
    })
    if (any(missing.required.quantities.mask))
        stop(paste0("The following required model.quantities have not been registered with the transition.mapping:\n",
                    paste0("- '", names(REQUIRED.MODEL.QUANTITY.SCHEMA)[missing.required.quantities.mask], "'", collapse='\n')))
    
    #-- Make the list of top-level quantities from which we will recurse down --#
    if (verbose)
        print("Getting top-level quantity names")
    top.level.quantity.names = get.top.level.model.quantity.names(transition.mapping)
    
    #-- Make sure there are no circular references --#
    #-- Make sure that any reference to 'super' and 'this' (in parent mapping) model.quantities are valid --#
    #-- Identify all the quantities and elements we will need --#
    #     (Either in this mapping or in an ancestor mapping)    #
    if (verbose)
        print("Parsing the transition mapping tree")
    parsed.names = parse.transition.mapping.tree(transition.mapping,
                                                 element.or.quantity.names = top.level.quantity.names)
    
    #-- Check for missing model.quantities or model.elements that have not been registered --#
    if (verbose)
        print("Check for missing or excess quantities/elements")
    if (length(parsed.names$unknown.names.and.depths$name)>0)
        stop(paste0("The following name(s) are required in the definition of model quantities or transitions, ",
                    "but have not been registered as either model.quantities or model.elements:\n",
                    paste0("- '", parsed.names$unknown.names.and.depths$name, "'", collapse='\n')))
    
    #-- Check for model.quantities or model.elements that have been registered but not used --#
    surplus.quantity.names = setdiff(names(transition.mapping$model.quantities),
                                     parsed.names$quantity.names.and.depths$name)
    
    if (length(surplus.quantity.names)>0)
        cat(paste0("*** WARNING: The following have been registered as model quantities, but are not actually used to define any transitions or required model quantities:\n",
                     paste0("- '", surplus.quantity.names, "'", collapse='\n'),
                     "\nThey will be ignored.\n"))
    
    surplus.element.names = setdiff(names(transition.mapping$model.elements),
                                    parsed.names$element.names.and.depths$name)
    if (length(surplus.element.names)>0)
        cat(paste0("*** WARNING: The following have been registered as transition elements, but are not actually used to define any transitions or required model quantities:\n",
                     paste0("- '", surplus.element.names, "'", collapse='\n'),
                     "\nThey will be ignored.\n"))
    
    #-- Identify new names for super quantities/elements if needed --#
    #-- Create a new, flattened (parentless) mapping with just the elements we need --#
    #--   (pull down from ancestor mappings) --#
    #-- Rename reference to renamed quantities/elements --#
    if (verbose)
        print("Pulling down and creating the new (slimmed) transition mapping")
    transition.mapping = create.slimmed.renamed.transition.mapping(template.mapping = transition.mapping,
                                                                   parsed.names = parsed.names)    
    
    #-- Reduce the model quantities (eliminate ones that only contain model elements) --#
    if (verbose)
        print("Reducing model quantities")
    for (quantity.name in parsed.names$quantity.names.and.depths$name)
        transition.mapping = reduce.model.quantity(transition.mapping,
                                                   quantity.name=quantity.name)

    #-- Strip out model quantities that have been eliminated by reducing --#
    dependencies = unique(unlist(sapply(transition.mapping$model.quantities, function(quantity){
        quantity$depends.on
    })))
    
    
    # Eliminate quantities
    to.eliminate.quantities = setdiff(names(transition.mapping$model.quantities),
                                      top.level.quantity.names)
    to.eliminate.quantities = setdiff(to.eliminate.quantities, dependencies)
    keep.quantities.mask = sapply(names(transition.mapping$model.quantities), function(name){
        all(name != to.eliminate.quantities)
    })
    
    transition.mapping$model.quantities = transition.mapping$model.quantities[keep.quantities.mask]
    
    # Eliminate elements
    to.eliminate.elements = setdiff(names(transition.mapping$model.elements),
                                    dependencies)
    keep.elements.mask = sapply(names(transition.mapping$model.elements), function(name){
        all(name != to.eliminate.elements)
    })
    
    transition.mapping$model.elements = transition.mapping$model.elements[keep.elements.mask]
    
    
    #-- Convert logical and integer state names to characters --#
    #-- Substitute mapped state names --#
    #-- Make sure that applies.to states are valid for the corresponding dimensions --#
    if (verbose)
        print("Finalizing state names")
    transition.mapping = finalize.model.quantity.state.names(transition.mapping,
                                                             specification=specification)
    
    
    #-- Check to make sure that model.quantity components do not have overlapping applies.to --#
    if (verbose)
        print("Checking overlapping applies.to in quantities")
    sapply(transition.mapping$model.quantities, check.overlapping.applies.to)
    
    
    #-- Check that specified subgroups are valid for transitions --#
    if (verbose)
        print("Checking transition subgroups")
    check.transition.subgroups.valid(transition.mapping, specification=specification)
    
    #-- Check that applies.to dimensions are valid for top.level subgroups --#
    if (verbose)
        print("Checking top-level dimensions valid for top level sub-groups")
    check.dimensions.valid.for.subgroups(transition.mapping, specification=specification)

    
    #-- Calculate the required dimensions and dim.names for each model.quantity and transition element --#
    #-- Check that applies.to dimensions are a subset of the calculated dim.names --#
    if (verbose)
        print("Calculating model quantity dim.names")
    for (quantity.name in names(transition.mapping$model.quantities))
    {
        transition.mapping = 
            calculate.model.quantity.or.model.element.dim.names(transition.mapping,
                                                                specification = specification,
                                                                quantity.or.element.name = quantity.name,
                                                                force.recalculate = F)
    }
    
    if (verbose)
        print("Calculating model element dim.names")
    for (element.name in names(transition.mapping$model.elements))
    {
        transition.mapping = 
            calculate.model.quantity.or.model.element.dim.names(transition.mapping,
                                                                specification = specification,
                                                                quantity.or.element.name = element.name,
                                                                force.recalculate = F)
    }
    
    #-- ???Map transition elements to subgroups and transition dimensions --#
    # DO I ACTUALLY NEED TO DO THIS?
    
    #-- Check that numeric values of model quantity subcomponents have appropriate dimensions --#
    check.model.quantity.value.dimensions(transition.mapping)

    #-- Check that models for model.elements have appropriate dimensions --#
    check.model.element.model.dimensions(transition.mapping)
    
    #-- Check that default values of model elements have appropriate dimensions --#
    if (verbose)
        print("Checking default values of model elements")
    check.model.elements.values(transition.mapping)
    
    #-- Set up the subset.expand.instructions for each quantity/element used in each component of each quantity --#
    for (quantity.name in names(transition.mapping$model.quantities))
        transition.mapping = derive.subset.expand.instructions.for.quantity(transition.mapping,
                                                                            quantity.name = quantity.name)
    
    if (verbose)
        print("Done finalizing transition mapping")
    
    #-- Return --#
    transition.mapping
}

#-- Finalize Helpers --#

get.top.level.model.quantity.names <- function(transition.mapping)
{
    required.names = names(REQUIRED.MODEL.QUANTITY.SCHEMA)

    transition.mask = sapply(transition.mapping$model.quantities, function(quantity){
        quantity$type == 'transition'
    })
    
    transition.names = names(transition.mapping$model.quantities)[transition.mask]
    
    if (is.null(transition.mapping$parent.mapping))
        inherited.names = character()
    else
        inherited.names = setdiff(get.top.level.model.quantity.names(transition.mapping$parent.mapping),
                                  transition.mapping$do.not.inherit.model.quantity.or.element.names)
    
    union(union(required.names,
                transition.names),
          inherited.names)
}

#-- Parse through the model quantity tree, across ancestor mappings --#

# Accomplishes two goals
#   1) Checks for circular references
#   2) Generates a list of every model.quantity and model.element we need (from which depth of ancestor)
#
# The return value is a list with three elements:
# $quantity.names.and.depths - with two sub-elements $name and $depth
# $element.names.and.depths - with two sub-elements $name and $depth
# $unknown names.and.depths - with two sub-elements $name and $depth
parse.transition.mapping.tree <- function(transition.mapping,
                                          element.or.quantity.names,
                                          ancestor.names.and.depth=list(name=character(), depth=numeric()),
                                          this.mapping.depth=0)
{
    if (length(element.or.quantity.names)>1) #Recurse on each one and merge
    {
        rv = NULL
        for (one.name in element.or.quantity.names)
        {
            sub.rv = parse.transition.mapping.tree(transition.mapping,
                                                   element.or.quantity.names = one.name,
                                                   ancestor.names.and.depth = ancestor.names.and.depth,
                                                   this.mapping.depth = this.mapping.depth)

            if (is.null(rv))
                rv = sub.rv
            else
            {
                rv$quantity.names.and.depths = union.pairs(rv$quantity.names.and.depths,
                                                           sub.rv$quantity.names.and.depths)
                rv$element.names.and.depths = union.pairs(rv$element.names.and.depths,
                                                           sub.rv$element.names.and.depths)
                rv$unknown.names.and.depths = union.pairs(rv$unknown.names.and.depths,
                                                          sub.rv$unknown.names.and.depths)
            }
            
        }
        
        rv
    }
    else #Do the work
    {
        name = element.or.quantity.names #there's only one. Alias for readability
        
        # Pull the value and what depth of ancestor we got it from
        quantity.and.depth = get.model.element.or.quantity.and.mapping.depth(transition.mapping,
                                                                             element.or.quantity.name = name,
                                                                             this.mapping.depth = this.mapping.depth)

        if (is.null(quantity.and.depth$element.or.quantity))
        {
            list(quantity.names.and.depths = list(name=character(), depth=integer()),
                 element.names.and.depths =  list(name=character(), depth=integer()),
                 unknown.names.and.depths = list(name=name, depth=this.mapping.depth))
        }
        else if (quantity.and.depth$type=='element')
        {
            model.element = quantity.and.depth$element.or.quantity
            this.mapping.depth = quantity.and.depth$depth
            
            list(quantity.names.and.depths = list(name=character(), depth=integer()),
                 element.names.and.depths =  list(name=model.element$name, depth=this.mapping.depth),
                 unknown.names.and.depths = list(name=character(), depth=integer()))
        }
        else
        {
            # Pull the values out of the list for readability
            model.quantity = quantity.and.depth$element.or.quantity
            this.mapping.depth = quantity.and.depth$depth
            
            # Check for circular references
            if (any(ancestor.names.and.depth$name == model.quantity$name &
                    ancestor.names.and.depth$depth == this.mapping.depth))
                stop(paste0("There is a circular reference through model.quantity '",
                            model.quantity$name, "'",
                            ifelse(this.mapping.depth==0,
                                   "",
                                   paste0(" in the ", get.ordinal(this.mapping.depth), " ancestor mapping"))))
            
            # Make an rv out of this name
            rv = list(quantity.names.and.depths = list(name=model.quantity$name, depth=this.mapping.depth),
                     element.names.and.depths =  list(name=character(), depth=integer()),
                     unknown.names.and.depths = list(name=character(), depth=integer()))
            
            # Recurse down on depends, and add them to the list
            if (length(model.quantity$depends.on)>0)
            {
                ancestor.names.and.depth$name = c(ancestor.names.and.depth$name, model.quantity$name)
                ancestor.names.and.depth$depth = c(ancestor.names.and.depth$depth, this.mapping.depth)
                
                sub.rv = parse.transition.mapping.tree(transition.mapping,
                                                       element.or.quantity.names = model.quantity$depends.on,
                                                       ancestor.names.and.depth = ancestor.names.and.depth,
                                                       this.mapping.depth = this.mapping.depth)
                
                rv$quantity.names.and.depths = union.pairs(rv$quantity.names.and.depths,
                                                           sub.rv$quantity.names.and.depths)
                rv$element.names.and.depths = union.pairs(rv$element.names.and.depths,
                                                          sub.rv$element.names.and.depths)
                rv$unknown.names.and.depths = union.pairs(rv$unknown.names.and.depths,
                                                          sub.rv$unknown.names.and.depths)
            }
            
            rv
        }
        
    }
}

#-- Renaming 'super.' and 'this.' quantities/elements --#

devise.quantity.rename.mapping <- function(names, depths)
{
    rename = sapply(1:length(names), function(i){
        matching.name = names[-i] == names[i]
        if (any(matching.name))
        {
            if (any(depths[-i][matching.name])<depths[i])
                paste0('super', depths[i], '_', names[i])
            else
                names[i]
        }
        else
            names[i]
    })
    
    list(name=names,
         depth=depths,
         rename=rename)
}

create.slimmed.renamed.transition.mapping <- function(template.mapping,
                                                      parsed.names)
{
    #-- Identify new names for super quantities/elements if needed --#
    rename.mapping = devise.quantity.rename.mapping(names = c(parsed.names$element.names.and.depths$name,
                                                              parsed.names$quantity.names.and.depths$name),
                                                    depths = c(parsed.names$element.names.and.depths$depth,
                                                               parsed.names$quantity.names.and.depths$depth))

    #-- Create a new, flattened (parentless) mapping with just the elements we need --#
    #--   (pull down quantities and elements from ancestor mappings) --#
    #-- Rename reference to renamed quantities/elements --#
    
    new.model.quantities = lapply(1:length(parsed.names$quantity.names.and.depths$name), function(i){
        name = parsed.names$quantity.names.and.depths$name[i]
        depth = parsed.names$quantity.names.and.depths$depth[i]
        
        new.name.mask = rename.mapping$name == name & rename.mapping$depth == depth
        if (sum(new.name.mask) != 1)
            stop("Error creating the renamed mapping for quantity - this should not happen")
        
        quantity = rename.quantity.depends.on(transition.mapping = template.mapping,
                                              quantity.name = name,
                                              mapping.depth = depth,
                                              rename.mapping = rename.mapping)

        quantity = rename.model.quantity(quantity, 
                                         new.name=rename.mapping$rename[new.name.mask],
                                         mapping.depth = depth)
        
        quantity
    })
    names(new.model.quantities) = sapply(new.model.quantities, function(quantity){quantity$name})
    
    new.model.elements = lapply(1:length(parsed.names$element.names.and.depths$name), function(i){
        name = parsed.names$element.names.and.depths$name[i]
        depth = parsed.names$element.names.and.depths$depth[i]
        
        new.name.mask = rename.mapping$name == name & rename.mapping$depth == depth
        if (sum(new.name.mask) != 1)
            stop("Error creating the renamed mapping for element - this should not happen")
        
        element = get.nth.ancestor.mapping(transition.mapping=template.mapping, n=depth)$model.elements[[name]]
        if (is.null(element))
            stop("Could not find the named element in the ancestor mapping - this should not happen")
        
        element = rename.model.element(element, 
                                         new.name=rename.mapping$rename[new.name.mask],
                                         mapping.depth = depth)
        
        element
    })
    names(new.model.elements) = sapply(new.model.elements, function(quantity){quantity$name})
    

    do.create.transition.mapping(version = version,
                                 
                                 model.quantities = new.model.quantities,
                                 model.elements = new.model.elements,
                                 
                                 parent.mapping = NULL,
                                 do.not.inherit.model.quantity.or.element.names = character(),
                                 
                                 finalized=T)
}

rename.quantity.depends.on <- function(transition.mapping,
                                            quantity.name,
                                            mapping.depth,
                                            rename.mapping)
{
    model.quantity = get.model.quantity(get.nth.ancestor.mapping(transition.mapping, mapping.depth),
                                        quantity.name = quantity.name)
    
    rename.to = lapply(model.quantity$depends.on, function(dep.on) {
        quantity.and.depth = get.model.element.or.quantity.and.mapping.depth(transition.mapping,
                                                                             element.or.quantity.name = dep.on,
                                                                             this.mapping.depth = mapping.depth)
        
        if (is.null(quantity.and.depth$element.or.quantity))
            stop("Error renaming super. and this. - should not happen")
        
        mask = rename.mapping$name == quantity.and.depth$element.or.quantity$name &
            rename.mapping$depth == quantity.and.depth$depth
        
        if (sum(mask)!=1)
            stop("Error renaming super. and this. - too many or too few rename matches - should not happen")
        
        rename.mapping$rename[mask]
    })
    names(rename.to) = model.quantity$depends.on
    
    model.quantity$components = lapply(model.quantity$components, function(comp){
        new.value = rename.expression.vars(comp$value, new.names = rename.to)
        set.model.quantity.component.value(comp, value=new.value)
    })

    # Update depends on and return
    model.quantity = calculate.model.quantity.depends.on(model.quantity)
    model.quantity
}


#-- Finalize state names --#

finalize.model.quantity.state.names <- function(transition.mapping,
                                                specification)
{
    transition.mapping$model.quantities =
        lapply(transition.mapping$model.quantities, function(quantity){
            quantity$components = lapply(1:length(quantity$components), function(i){
                comp = quantity$components[[i]]
                
                error.prefix = paste0("Error in finalizing state names for the ",
                                      get.ordinal(i),
                                      " component of model.quantity '",
                                      get.original.name(quantity), 
                                      "': ")
                
                for (dim in names(comp$applies.to))
                {
                    applies.to.value = comp$applies.to[[dim]]
                    if (all(names(specification$DIMENSION.NAMES) != dim))
                        stop(paste0(error.prefix, "'", dim, "' is not a valid dimension for applies.to"))
                    else if (is.character(applies.to.value))
                    {
                        comp$applies.to.value[[dim]] = substitute.into.vector(applies.to.value,
                                                                              mapping=specification$state.name.mapping)
                        
                        invalid.state.names = setdiff(comp$applies.to.value[[dim]],
                                                      specification$DIMENSION.NAMES[[dim]])
                        
                        if (length(invalid.state.names)>0)
                            stop(paste0(error.prefix,
                                        "invalid state name(s) for the '", dim, "' dimension: ",
                                        paste0("'", invalid.state.names, "'", collapse=', ')))
                    }
                    else if (is.integer(applies.to.value))
                    {
                        if (any(applies.to.value<1))
                            stop(paste0(error.prefix,
                                        "the value for applies.to for dimension '", dim,
                                        "' was an integer vector which contained values less than 1."))
                        
                        if (any(applies.to.value>length(specification$DIMENSION.NAMES[[dim]])))
                            stop(paste0(error.prefix,
                                        "the value for applies.to for dimension '", dim,
                                        "' was an integer vector which contained indices that were out of bounds (greater than ",
                                        length(specification$DIMENSION.NAMES[[dim]]),
                                        ")"))
                        
                        comp$applies.to[[dim]] = specification$DIMENSION.NAMES[[dim]][applies.to.value]
                    }
                    else if (is.logical(applies.to.value))
                    {
                        if (length(applies.to.value) != length(specification$DIMENSION.NAMES[[dim]]))
                            stop(paste0(error.prefix,
                                        "the value for applies.to for dimension '", dim,
                                        "' was a logical vector of length ",
                                        length(applies.to.value),
                                        ", but the '", dim,
                                        "' dimension has only ",
                                        length(specification$DIMENSION.NAMES[[dim]]),
                                        ifelse(length(specification$DIMENSION.NAMES[[dim]])==1,
                                               " state ",
                                               " states ")))
                        
                        comp$applies.to[[dim]] = specification$DIMENSION.NAMES[[dim]][applies.to.value]
                    }
                    else
                        stop(paste0(error.prefix,
                                    "the values of 'applies.to' must be either integer, logical, or character vectors"))
                }
                
                comp
            })
            
            # Return updated quantity
            quantity
        })
    
    transition.mapping
}


#-- Validate subgroups and dimension values --#

check.overlapping.applies.to <- function(model.quantity)
{
    if (length(model.quantity$components) > 2)
    {
        for (i in 2:(length(model.quantity$components)-1))
        {
            for (j in (i+1):length(model.quantity$components))
            {
                if (dimensions.overlap(model.quantity$components[[i]]$applies.to,
                                       model.quantity$components[[j]]$applies.to))
                    
                    if (model.quantity$type=='transition')
                        stop(paste0("Transitions to overlapping states have been set in the '",
                                    names(model.quantity$applies.to), 
                                    "' dimension for '",
                                    model.quantity$subgroup
                                    , "'",
                                    ifelse(is.null(model.quantity$mapping.depth) || model.quantity$mapping.depth==0,
                                           "",
                                           paste0("(from the ", get.ordinal(model.quantity$mapping.depth), " ancestor mapping)")),
                                    ". (the ",
                                    get.ordinal(i), " and ", get.ordinal(j),
                                    " components of the model.quantity)"))
                    else
                        stop(paste0("The ",
                                    get.ordinal(i), 
                                    " and ",
                                    get.ordinal(j),
                                    " components of model.quantity '",
                                    get.original.name(model.quantity),
                                    "' have overlapping applies.to values"))
            }
        }
    }
}

check.transition.subgroups.valid <- function(transition.mapping,
                                             specification)
{
    for (model.quantity in transition.mapping$model.quantities)
    {
        if (model.quantity$type == 'transition')
        {
            for (subgroup in model.quantity$subgroups)
            {
                if (all(names(specification$dimension.names.by.subgroup) != subgroup))
                    stop(paste0("'", subgroup, "' is not a valid subgroup for transitions"))
                
                for (i in 1:length(model.quantity$components))
                {
                    comp = model.quantity$components[[i]]
                    if (!is.null(comp$applies.to) && 
                        all(names(specification$dimension.names.by.subgroup[[subgroup]]) != model.quantity$subtype))
                        stop(paste0("'", subgroup, "' is not a valid subgroup for transitions in the '",
                                    model.quantity$subtype, "' dimension"))
                }        
            }
        }
    }
}

check.dimensions.valid.for.subgroups <- function(transition.mapping,
                                                 specification)
{
    for (model.quantity in transition.mapping$model.quantities)
    {
        if (!is.null(model.quantity$subgroups))
        {
            for (subgroup in model.quantity$subgroups)
            {
                invalid.dimensions = setdiff(names(model.quantity$applies.to),
                                             names(specification$dimension.names.by.subgroups[[subgroup]]))
                
                if (length(invalid.dimensions)>0)
                    stop(paste0("Invalid dimension(s) for subgroup '", subgroup,
                                " in model.quantity '",
                                get.original.name(model.quantity),
                                "': ",
                                paste0("'", invalid.dimensions, "'", collapse=', ')))
            }
        }
    }
}

#-- Deriving the dimension names --#

# Modifies the transition mapping and returns the updated mapping
# 
# The dim.names for this element/quantity are a function of all of the following
# - The dim.names of any model.quantity component which depends on this quantity or element
# - The dim.names of the relevant subgroup if this is a required (top-level) model quantity
# 
# The dim.names from each of the above are combined to give the dim.names of this element/quantity as follows (the union of dim.names):
# - Any dimension that does not appear in ALL the dim.names above is dropped
# - For any dimension that does appear in ALL the dim.names above, the value is the union of the values for that dimension in each of the dim.names above
# 
# Deals with the flattened mapping (no parent mappings)
# Also assumes we have already eliminated circular dependencies
calculate.model.quantity.or.model.element.dim.names <- function(transition.mapping,
                                                                specification,
                                                                quantity.or.element.name,
                                                                force.recalculate)
{
    is.quantity = any(names(transition.mapping$model.quantities)==quantity.or.element.name)
    is.element = any(names(transition.mapping$model.elements)==quantity.or.element.name)
    
    if (!is.quantity && !is.element)
        stop(paste0("'", quantity.or.element.name, 
                    "' has not been registered as a model.quantity or model element with this transition.mapping"))
    
    dim.names.and.aliases = list(dim.names=NULL, aliases=NULL)
    # If it is a model.quantity with subgroups set
    if (is.quantity)
    {
        quantity = get.model.quantity(transition.mapping, 
                                      quantity.name=quantity.or.element.name,
                                      throw.error.if.missing = T)
        quantity.or.element = quantity
        
        if (!is.null(quantity$subgroups))
        {
            for (subgroup in quantity$subgroups)
            {
                if (quantity$type=='transition')
                    dim.names.to.add = get.transition.dim.names(dimension = quantity$subtype,
                                                                subgroup = subgroup,
                                                                specification = specification)
                else
                    dim.names.to.add = specification$dimension.names.by.subgroup[[subgroup]]
                dim.names.and.aliases = union.shared.dim.names.with.aliases(dim.names.1 = dim.names.and.aliases$dim.names,
                                                                            aliases.1 = dim.names.and.aliases$aliases,
                                                                            dim.names.2 = dim.names.to.add,
                                                                            aliases.2 = quantity$dimension.aliases,
                                                                            specification = specification)
            }
        }
    }
    else
        quantity.or.element = get.model.element(transition.mapping, 
                                                element.name = quantity.or.element.name,
                                                throw.error.if.missing = T)
    
    # Any model.quantity.component that contains this element/quantity
    for (quantity.name in names(transition.mapping$model.quantities))
    {
        model.quantity = transition.mapping$model.quantities[[quantity.name]]
        if (any(model.quantity$depends.on == quantity.or.element.name))
        {
            for (i in 1:length(model.quantity$components))
            {
                transition.mapping = calculate.model.quantity.component.dim.names(transition.mapping,
                                                                                  specification = specification,
                                                                                  quantity.name = quantity.name,
                                                                                  component.index = i,
                                                                                  force.recalculate = force.recalculate)

                dim.names.to.add = transition.mapping$model.quantities[[quantity.name]]$components[[i]]$dim.names
                aliases.to.add = transition.mapping$model.quantities[[quantity.name]]$components[[i]]$dimension.aliases
                
                
                dim.names.and.aliases = union.shared.dim.names.with.aliases(dim.names.1 = dim.names.and.aliases$dim.names,
                                                                            aliases.1 = dim.names.and.aliases$aliases,
                                                                            dim.names.2 = dim.names.to.add,
                                                                            aliases.2 = aliases.to.add,
                                                                            specification = specification)
            }
        }
    }
    
    dim.names = dim.names.and.aliases$dim.names
    aliases = dim.names.and.aliases$aliases
    
    # Check for empty dim.names - an error
    if (is.null(dim.names))
        stop(paste0("No dim.names are able to be set for '", 
                    get.original.name(quantity.or.element),
                    "' - no ancestors have dim.names set"))
    else if (length(dim.names)==0)
        stop(paste0("The ancestors of '", 
                    get.original.name(quantity.or.element),
                    '" have completely non-overlapping dim.names'))
    
    # set the dim.names attribute
    if (is.quantity)
    {
        transition.mapping$model.quantities[[quantity.or.element.name]]$dim.names = dim.names
        if (is.null(transition.mapping$model.quantities[[quantity.or.element.name]]$subgroups))
            transition.mapping$model.quantities[[quantity.or.element.name]]$dimension.aliases = aliases #we can only overwrite if this does not have subgroups set - ie, if it is not satisfying required dimensions for itself
    }
    else
        transition.mapping$model.elements[[quantity.or.element.name]]$dim.names = dim.names
    
    # Return the transition mapping
    transition.mapping
}


# Modifies the transition mapping and returns the updated mapping
# 
# A model.quantity component's dim.names are the parent model.quantity's dimnames
# intersected with the dim.names in applies.to
calculate.model.quantity.component.dim.names <- function(transition.mapping,
                                                         specification,
                                                         quantity.name,
                                                         component.index,
                                                         force.recalculate=F)
{
    quantity = transition.mapping$model.quantities[[quantity.name]]
    comp = quantity$components[[component.index]]
    if (force.recalculate || is.null(comp$dim.names))
    {
        if (force.recalculate || is.null(quantity$dim.names))
        {
            transition.mapping = calculate.model.quantity.or.model.element.dim.names(transition.mapping,
                                                                                     specification = specification,
                                                                                     quantity.or.element.name = quantity.name,
                                                                                     force.recalculate=force.recalculate)
            
            quantity = transition.mapping$model.quantities[[quantity.name]]
        }
        
        dim.names = quantity$dim.names
        
        # Check that applies to is contained in the parent
        # If so, intersect with dim.names
        if (!is.null(comp$applies.to))
        {
            invalid.dims = setdiff(names(comp$applies.to), names(dim.names))
            if (length(invalid.dims)>0)
            {
                invalid.dims.after.aliases = setdiff(replace.with.aliases(names(comp$applies.to), aliases=quantity$dimension.aliases),
                                                     names(dim.names))
                invalid.dims = intersect(invalid.dims, invalid.dims.after.aliases)
            }
            if (length(invalid.dims)>0)
                browser()
            if (length(invalid.dims)>0)
                stop(paste0("The ", get.ordinal(component.index), " component of model.quantity '",
                            quantity.name, "' ('", names(quantity$components[[component.index]]), 
                            "') is mis-specified. Dimension(s) ",
                            paste0("'", invalid.dims, "'", collapse=', '),
                            " are specified as dimension(s) for applies.to, but are not dimension(s) in the parent model.quantity"))

            for (dim in names(comp$applies.to))
            {
                invalid.applies.to.values = setdiff(comp$applies.to[[dim]], dim.names[[dim]])
                if (length(invalid.applies.to.values))
                    stop(paste0("The ", get.ordinal(component.index), " component of model.quantity '",
                                quantity.name, "' ('", names(quantity$components[[component.index]]), 
                                "') is mis-specified. applies.to[[", dim, "]] = <",
                                paste0(comp$applies.to[[dim]], collapse=', '),
                                ">, but ",
                                paste0("'", invalid.applies.to.values, "'", collapse=', '),
                                " is/are not values for the '", dim,
                                "' dimension in the parent model.quantity"))
                
                dim.names[[dim]] = comp$applies.to[[dim]]
            }
        }
        
        transition.mapping$model.quantities[[quantity.name]]$components[[component.index]]$dim.names = dim.names
        transition.mapping$model.quantities[[quantity.name]]$components[[component.index]]$dimensions = names(dim.names)
    }
    
    transition.mapping
}

check.model.elements.values <- function(transition.mapping)
{
    sapply(transition.mapping$model.elements, function(element){
        if (!is.null(element$value) &&
            !value.fits.into.dim.names(value=element$value, dim.names=element$dim.names))
            stop(paste0("Invalid value for model element '",
                        get.original.name(element), 
                        "': the dimensions of the value do not fit into the expected dimensions for the element"))
    })
}

check.model.element.model.dimensions <- function(transition.mapping)
{
    sapply(transition.mapping$model.elements, function(element){
        if (!is.null(element$model))
            do.check.model.dimensions(element)
    })
}

do.check.model.dimensions <- function(element, model=element$model)
{
    if(!are.dim.names.subset(sub.dim.names = get.model.dim.names(element$model),
                          super.dim.names = element$dim.names))
    stop(paste0("Invalid model dimensions for model element '",
                get.original.name(element), 
                "': the dimensions of the given model do not fit into the expected dimensions for the element"))
}

check.model.quantity.value.dimensions <- function(transition.mapping)
{
    sapply(transition.mapping$model.quantities, function(quantity){
        sapply(1:length(quantity$components), function(i){
            comp = quantity$components[[i]]
            if (is.numeric(comp$value) &&
                !value.fits.into.dim.names(value=comp$value, dim.names=comp$dim.names))
                stop(paste0("Invalid value for the ",
                            get.ordinal(i), " value of model.quantity '",
                            get.original.name(quantity), 
                            "': the dimensions of the value do not fit into the expected dimensions for the component"))
            
        })
    })
}

#-- Deriving subset.expand.instructions --#
derive.subset.expand.instructions.for.quantity <- function(transition.mapping,
                                                           quantity.name = quantity.name)
{
    model.quantity = get.model.quantity(transition.mapping, quantity.name=quantity.name)
    transition.mapping$model.quantities[[quantity.name]]$components = 
        lapply(1:length(model.quantity$components), function(i){
            comp = model.quantity$components[[i]]
            comp$subset.expand.instructions.for.depends.on = lapply(comp$depends.on, function(depends.on){
                make.subset.expand.instructions(transition.mapping,
                                                model.quantity = model.quantity,
                                                component.index = i,
                                                depends.on = depends.on)
            })
            names(comp$subset.expand.instructions.for.depends.on) = comp$depends.on
            
            comp$access.indices.into.quantity = get.access.indices(dim.names=model.quantity$dim.names,
                                                                   access.dims=comp$applies.to)
            
            comp
        })
    
    transition.mapping
}

make.subset.expand.instructions <- function(transition.mapping,
                                            model.quantity,
                                            component.index,
                                            depends.on)
{
    error.prefix = paste0("Could not make subset.expand.instructions for the ",
                          get.ordinal(component.index), " component of model.quantity '",
                          model.quantity$name, "' dependency on '", depends.on, "': ")
    
    model.quantity.component = model.quantity$components[[component.index]]
    
    element.or.quantity = get.model.element(transition.mapping, element.name = depends.on, throw.error.if.missing = F)
    if (is.null(element.or.quantity))
        element.or.quantity = get.model.quantity(transition.mapping, quantity.name = depends.on, throw.error.if.missing = F)
    
    source.dim.names = element.or.quantity$dim.names
    target.dim.names = model.quantity.component$dim.names
    
    source.dimensions = names(source.dim.names)
    target.dimensions = names(target.dim.names)
    
    source.dims = sapply(source.dim.names, length)
    
    #-- Figure out the subsetting indices --#
    
    # Dimensions in target but not source 
    # -> always OK (will just be filled by expanding), don't need to check
    
    # Dimensions in source but not in target
    # -> try using dimension aliases
    dimensions.in.source.not.target = setdiff(source.dimensions, target.dimensions)
    aliased.dimensions.in.source.not.target = intersect(model.quantity$dimension.aliases, dimensions.in.source.not.target)
    if (length(aliased.dimensions.in.source.not.target)>0)
    {
        source.dimensions = sapply(source.dimensions, function(dim){
            if (any(dim==dimensions.in.source.not.target))
                model.quantity$reversed.aliases[dim]
            else
                dim
        })
        names(source.dim.names) = source.dimensions
        dimensions.in.source.not.target = setdiff(source.dimensions, target.dimensions)
    }
    
    # Dimensions in source but not in target (after using aliases)
    # -> OK only if length 1, in which case ignore and drop from dimnames after subsetting (otherwise error)
    if (length(dimensions.in.source.not.target)>0)
    {
        if (any(source.dims[dimensions.in.source.not.target]>1))
            stop(paste0(error.prefix,
                        "Dimension(s) are present in source.dim.names but not in target.dim.names: ",
                        paste0("'", dimensions.in.source.not.target[source.dims[dimensions.in.source.not.target]>1],
                               "'", collapse=', ')))
    }
    
    
    # Dimensions in both, with equal dim values 
    # -> don't need to do anything, ignore
    overlapping.dimensions = intersect(source.dimensions, target.dimensions)
    overlapping.dimensions.equal = sapply(overlapping.dimensions, function(dim){
        length(source.dim.names[[dim]]) == length(target.dim.names[[dim]])
    })
    
    # Dimensions in both, dim values not equal, source dim values are superset of target dim values
    # -> need to set up an access mask
    overlapping.nonequal.dimensions = overlapping.dimensions[!overlapping.dimensions.equal]
    overlapping.and.source.dim.values.is.superset = sapply(overlapping.nonequal.dimensions, function(dim){
        length(setdiff(target.dim.names[[dim]], source.dim.names[[dim]]))==0
    })
    
    if (any(overlapping.and.source.dim.values.is.superset))
    {
        need.to.subset.dimensions = overlapping.nonequal.dimensions[overlapping.and.source.dim.values.is.superset]
        access.indices = get.access.indices(dim.names=source.dim.names,
                                            access.dims=target.dim.names[need.to.subset.dimensions])
    }
    else
        access.indices = NULL
    
    # Dimensions in both, dim values not equal, and some target dim values are not in source dim values
    # -> error
    if (any(!overlapping.and.source.dim.values.is.superset))
    {
        error.dimensions = overlapping.nonequal.dimensions[!overlapping.and.source.dim.values.is.superset]
        stop(paste0(error.prefix,
                    "The target.dim.names for dimension(s) ",
                    paste0("'", error.dimensions, "'", collapse=', '),
                    " contain values not present in source.dim.names"))
    }
    
    #-- Figure out the dim.names after subsetting --#
    dimensions.in.source.and.target = intersect(source.dimensions, target.dimensions)
    dim.names.after.subset = target.dim.names[dimensions.in.source.and.target]
    
    #-- Set the expand.to dim.names (just the model.quantity.component's dim names) --#
    expand.to.dim.names = target.dim.names
   
    #-- Package it up and return --#
    rv = list(subset.indices = access.indices,
              dim.after.subset = sapply(dim.names.after.subset, length),
              dim.names.after.subset = dim.names.after.subset,
              expand.to.dim.names = expand.to.dim.names)
    
    class(rv) = 'subset.expand.instructions'
    rv
}

apply.subset.expand.instructions <- function(value,
                                             instructions,
                                             pass.through.scalar=T)
{
    if (is.null(dim(value)) && length(value)==1)
    {
        if (pass.through.scalar)
            value
        else
            expand.population(value, instructions$expand.to.dim.names)
    }
    else
    {
        if (!is.null(instructions$subset.indices))
            value = value[instructions$subset.indices]
        
        dim(value) = instructions$dim.after.subset
        dimnames(value) = instructions$dim.names.after.subset
        
        if (!is.null(instructions$expand.to.dim.names))
            value = expand.population(value,
                                      target.dim.names = instructions$expand.to.dim.names)
        
        value
    }
}

##------------------------------------------##
##-- GENERAL TRANSMISSION MAPPING HELPERS --##
##------------------------------------------##


is.model.quantity.name <- function(transition.mapping,
                                   names)
{
    rv = sapply(names, function(name){
        any(names(transition.mapping$model.quantities)==name)
    })
    
    if (any(!rv) && !transition.mapping$finalized && !is.null(transition.mapping$parent.mapping))
        rv[!rv] = is.model.quantity.name(transition.mapping$parent.mapping,
                                         names = names[!rv])
    
    as.logical(rv)
}

is.model.element.name <- function(transition.mapping,
                                  names)
{
    rv = sapply(names, function(name){
        any(names(transition.mapping$model.elements)==name)
    })
    
    if (any(!rv) && !transition.mapping$finalized && !is.null(transition.mapping$parent.mapping))
        rv[!rv] = is.model.element.name(transition.mapping$parent.mapping,
                                        names = names[!rv])
    
    as.logical(rv)
}



# two sets of dim.values overlap if either
# 1) they do not name any dimensions in common (the unspecified dimensions overlap)
# 2) all of the dimensions present in both sets of values overlap on at least one value
# dim.values are the values of dimensions to subset (unspecified dimensions keep all values)
dimensions.overlap <- function(dim.values.1, dim.values.2)
{
    overlapping.dimensions = intersect(names(dim.values.1), names(dim.values.2))
    length(overlapping.dimensions)==0 ||
        all(sapply(overlapping.dimensions, function(dim){
            
            values1 = dim.values.1[[dim]]
            values2 = dim.values.2[[dim]]
            
            if ((is.character(values1) && is.character(values2)) ||
                is.integer(values1) && is.integer(values2))
            {
                length(intersect(values1, values2)) > 0
            }
            else if (is.logical(values1) && is.logical(values2) && length(values1)==length(values2))
            {
                any(values1 & values2)
            }
            else if (is.integer(values1) && is.logical(values2))
            {
                values2 = (1:length(values2))[values2]
                length(intersect(values1, values2))>0
            }
            else if (is.logical(values1) && is.integer(values2))
            {
                values1 = (1:length(values1))[values1]
                length(intersect(values1, values2))>0
            }
            else
                F
        }))
}

#-- Helpers for transitions --#
check.from.to.value <- function(value,
                                error.descriptor)
{
    MESSAGE = paste0("'", error.descriptor, "' must be either a non-empty character value, a vector of integer values >= 1, or a logical vector with at least one TRUE value. NAs are not permitted")
    if (!is.vector(value) || any(is.na(value)))
        stop(MESSAGE)
    
    if (is.character(value))
    {
        if (length(value) == 0 || any(value==''))
            stop(MESSAGE)
    }
    else if (is.integer(value))
    {
        if (length(value) == 0  || any(value) <1)
            stop(MESSAGE)
    }
    else if (is.logical(value))
    {
        if (sum(value) == 0)
            stop(MESSAGE)
    }
    else
        stop(MESSAGE)
}


get.dimension.transition.quantity.name <- function(dimension, subgroup)
{
    paste0("transition_", rep(dimension, length(subgroup)),
           "_", rep(subgroup, each=length(dimension)))
}

get.specific.transition.name <- function(from, to, subgroups)
{
    paste0('transition.',
           paste0(from, collapse='.'),
           '.to.',
           paste0(to, collapse='.'),
           '.',
           paste0(subgroups, collapse='.'))
}

is.specific.transition.name <- function(name)
{
    substr(name, 1, 11) == 'transition.'
}

get.original.name <- function(quantity.or.element)
{
    if (is.null(quantity.or.element$original.name))
        quantity.or.element$name
    else if (quantity.or.element$mapping.depth==0)
        quantity.or.element$original.name
    else
        paste0(quantity.or.element$original.name, 
               " (from the ",
               get.ordinal(quantity.or.element$mapping.depth),
               " ancestor mapping)")
        
}

##-------------------------------------------------##
##-- HELPERS FOR PARSING THE LINEAGE OF MAPPINGS --##
##-------------------------------------------------##


# private to this code file
# mapping depth 0 is this transition.mapping
# depth 1 is this mapping's parent mapping
# depth 2 is the parent's parent
# etc
get.model.quantity.and.mapping.depth <- function(transition.mapping, quantity.name,
                                                 start.mapping.depth=0)
{
    rv = list(quantity=transition.mapping$model.quantities[[quantity.name]],
              depth=start.mapping.depth)
    
    if (is.null(rv$quantity) && !transition.mapping$finalized && !is.null(transition.mapping$parent.mapping) && 
        all(transition.mapping$do.not.inherit.model.quantity.or.element.names != quantity.name))
        rv = get.model.quantity.and.mapping.depth(transition.mapping$parent.mapping,
                                                  quantity.name=quantity.name,
                                                  start.mapping.depth=start.mapping.depth+1)
    
    rv
}

# private to this code file
# mapping depth 0 is this transition.mapping
# depth 1 is this mapping's parent mapping
# depth 2 is the parent's parent
# etc
get.model.element.and.mapping.depth <- function(transition.mapping, element.name,
                                                start.mapping.depth=0)
{
    rv = list(element=transition.mapping$model.elements[[element.name]],
              depth=start.mapping.depth)
    
    if (is.null(rv$element) && !transition.mapping$finalized && !is.null(transition.mapping$parent.mapping) && 
        all(transition.mapping$do.not.inherit.model.quantity.or.element.names != element.name))
        rv = get.model.element.and.mapping.depth(transition.mapping$parent.mapping,
                                                 element.name=element.name,
                                                 start.mapping.depth=start.mapping.depth+1)
    
    rv
}

# handles "super." and "this." references
get.model.element.or.quantity.and.mapping.depth <- function(transition.mapping,
                                                            element.or.quantity.name,
                                                            this.mapping.depth=0)
{
    if (is.quantity.name.super.reference(element.or.quantity.name))
    {
        transition.mapping = get.nth.ancestor.mapping(transition.mapping, this.mapping.depth+1)
        mapping.depth = this.mapping.depth+1
    }
    else if (is.quantity.name.this.reference(element.or.quantity.name))
    {
        transition.mapping = get.nth.ancestor.mapping(transition.mapping, this.mapping.depth)
        mapping.depth = this.mapping.depth
    }
    else
    {
        mapping.depth = 0
    }
    
    type = 'quantity'
    rv = get.model.quantity.and.mapping.depth(transition.mapping,
                                              quantity.name = element.or.quantity.name,
                                              start.mapping.depth = mapping.depth)
    
    if (is.null(rv$quantity))
    {
        type = 'element'
        rv = get.model.element.and.mapping.depth(transition.mapping,
                                                 element.name = element.or.quantity.name,
                                                 start.mapping.depth = mapping.depth)
    }
    
    names(rv)[1] = 'element.or.quantity'
    if (is.null(rv[[1]]))
    {
        rv$type = 'unknown'
        
        if (is.specific.transition.name(element.or.quantity.name)) #allow to match just the first part of the name
        {
            ancestor.names = get.ancestor.mapping.quantity.and.element.names(transition.mapping, include.this.names = T)
            matching.mask = substr(ancestor.names, 1, nchar(element.or.quantity.name)) == element.or.quantity.name
            if (sum(matching.mask)==1)
                rv = get.model.element.or.quantity.and.mapping.depth(transition.mapping,
                                                                     element.or.quantity.name = ancestor.names[matching.mask],
                                                                     this.mapping.depth = this.mapping.depth)
        }
    }
    else
        rv$type = type
    
    rv
}

get.ancestor.mapping.element.names <- function(transition.mapping, include.this.names)
{
    if (include.this.names)
        rv = names(transition.mapping$model.elements)
    else
        rv = character()
    
    if (!transition.mapping$finalized && !is.null(transition.mapping$parent.mapping))
        rv = union(rv, get.ancestor.mapping.element.names(transition.mapping$parent.mapping, 
                                                          include.this.names = T))
    
    rv
}


get.ancestor.mapping.quantity.names <- function(transition.mapping, include.this.names)
{
    if (include.this.names)
        rv = names(transition.mapping$model.quantities)
    else
        rv = character()
    
    if (!transition.mapping$finalized && !is.null(transition.mapping$parent.mapping))
        rv = union(rv, get.ancestor.mapping.element.names(transition.mapping$parent.mapping, 
                                                          include.this.names = T))
    
    rv
}

get.ancestor.mapping.quantity.and.element.names <- function(transition.mapping, include.this.names)
{
    c(get.ancestor.mapping.element.names(transition.mapping, 
                                         include.this.names = include.this.names),
      get.ancestor.mapping.quantity.names(transition.mapping,
                                          include.this.names = include.this.names))
}

is.quantity.name.this.reference <- function(quantity.name)
{
    tolower(substr(quantity.name,1,5)) == 'this.' |
        tolower(substr(quantity.name,1,5)) == 'this_'
}

is.quantity.name.super.reference <- function(quantity.name)
{
    tolower(substr(quantity.name,1,6)) == 'super.' |
        tolower(substr(quantity.name,1,6)) == 'super_'
}

get.quantity.name.from.this.reference <- function(quantity.name)
{
    substr(quantity.name, 6, nchar(quantity.name))
}

get.quantity.name.from.super.reference <- function(quantity.name)
{
    substr(quantity.name, 7, nchar(quantity.name))
}

get.nth.ancestor.mapping <- function(transition.mapping,
                                     n)
{
    i = 0;
    rv = transition.mapping
    while (i<n)
    {
        if (is.null(transition.mapping$parent.mapping))
            stop(paste0("The ",
                        get.ordinal(n), 
                        " ancestor mapping was requested, but the transition.mapping only has ",
                        i, " ancestor(s)"))
        
        transition.mapping = transition.mapping$parent.mapping
        i = i+1;
    }
    
    rv
}


##-----------------------##
##-- LOW-LEVEL HELPERS --##
##-----------------------##

# pairs1, pairs2 are lists
# each has two values, which are vectors of the same length
union.pairs <- function(pairs1, pairs2)
{
    if (length(pairs1[[1]])==0)
        keep1.mask = logical()
    else if (length(pairs1[[1]])==1)
        keep1.mask = T
    else
        keep1.mask = c(T,
                       sapply(2:length(pairs1[[1]]), function(i){
                           !any(sapply(1:(i-1), function(j){
                               pairs1[[1]][i] == pairs1[[1]][j] &&
                                   pairs1[[2]][i] == pairs1[[2]][j]
                           }))
                       }))
    
    if (length(pairs2[[1]])==0)
        keep2.mask = logical()
    else if (length(pairs1[[1]])==0)
        keep2.mask = rep(T, length(pairs2[[1]]))
    else
        keep2.mask = sapply(1:length(pairs2[[1]]), function(j){
            !any(sapply(1:length(pairs1[[1]]), function(i){
                pairs1[[1]][i] == pairs2[[1]][j] &&
                    pairs1[[2]][i] == pairs2[[2]][j]
            }))
        })
    
    pairs1[[1]] = c(pairs1[[1]][keep1.mask], pairs2[[1]][keep2.mask])
    pairs1[[2]] = c(pairs1[[2]][keep1.mask], pairs2[[2]][keep2.mask])
    
    pairs1
}

# pairs1, pairs2 are lists
# each has two values, which are vectors of the same length
intersect.pairs <- function(pairs1, pairs2)
{
    pairs1 = unique.pairs(pairs1)
    
    if (length(pairs1[[1]])==0 || length(pairs2[[1]])==0)
        keep1.mask = logical()
    else
        keep1.mask = sapply(1:length(pairs1[[1]]), function(i){
            any(sapply(1:length(pairs2[[1]]), function(j){
                pairs1[[1]][i] == pairs2[[1]][j] &&
                    pairs1[[2]][i] == pairs2[[2]][j]
            }))
        })
    
    pairs1[[1]] = pairs1[[1]][keep1.mask]
    pairs1[[2]] = pairs1[[2]][keep1.mask]
    pairs1
}

# pairs is a list with two values, which are vectors of the same length
unique.pairs <- function(pairs)
{
    if (length(pairs)>1)
    {
        keep1.mask = c(T,
                       sapply(2:length(pairs[[1]]), function(i){
                           !any(sapply(1:(i-1), function(j){
                               pairs[[1]][i] == pairs[[1]][j] &&
                                   pairs[[2]][i] == pairs[[2]][j]
                           }))
                       }))
        
        pairs[[1]] = pairs[[1]][keep1.mask]
        pairs[[2]] = pairs[[2]][keep1.mask]
    }
    
    pairs
}


value.fits.into.dim.names <- function(value, dim.names)
{
    if (is.null(dim(value)))
    {
        if (length(value)==1)
            T
        else
        {
            !is.null(names(value)) &&
                any(sapply(dim.names, function(dim.values){
                    length(dim.values) == length(value) &&
                        all(dim.values == names(value))
                }))
        }
    }
    else
        are.dim.names.subset(sub.dim.names = dimnames(values),
                             super.dim.names = dim.names)
}

are.dim.names.subset <- function(sub.dim.names, super.dim.names)
{
    if (length(setdiff(names(sub.dim.names), names(super.dim.names)))>0)
        F
    else
    {
        all(as.logical(sapply(names(sub.dim.names), function(dim){
            length(sub.dim.names[[dim]]) == length(super.dim.names[[dim]]) &&
                all(sub.dim.names[[dim]] == super.dim.names[[dim]])
        })))
    }
}

get.transition.dim.names <- function(dimension,
                                     subgroup,
                                     specification)
{
    rv = c(specification$dimension.names.by.subgroup[[subgroup]],
           specification$DIMENSION.NAMES[paste0(dimension, '.to')])
    names(rv)[names(rv)==dimension] = paste0(dimension, '.from')
    
    rv
}

# - Any dimension that does not appear in ALL the dim.names above is dropped
# - For any dimension that does appear in ALL the dim.names above, the value is the union of the values for that dimension in each of the dim.names above
union.shared.dim.names <- function(dim.names.1, dim.names.2,
                                   specification)
{
    if (is.null(dim.names.1))
        dim.names.2
    else if (is.null(dim.names.2))
        dim.names.1
    else
    {
        overlapping.dimensions = intersect(names(dim.names.1), names(dim.names.2))
        rv = lapply(overlapping.dimensions, function(dim){
            intersect(specification$DIMENSION.NAMES[[dim]],
                      union(dim.names.1[[dim]], dim.names.2[[dim]]))
        })
        names(rv) = overlapping.dimensions
        rv
    }
}

# Returns a list with two elements
# $dim.names
# $aliases
# 
# aliases - a named character vector. The names of the vector correspond to current names of dimensions. The values correspond to the names they could be swapped for
union.shared.dim.names.with.aliases <- function(dim.names.1, aliases.1,
                                                dim.names.2, aliases.2,
                                                specification)
{
    if (is.null(dim.names.1))
        list(dim.names=dim.names.2, aliases=aliases.2)
    else if (is.null(dim.names.2))
        list(dim.names=dim.names.1, aliases=aliases.1)
    else
    {
        # Figure out which aliases we need to use
        aliases.1.in.dim.names.2.mask = as.logical(sapply(aliases.1, function(name){
            any(name == names(dim.names.2))
        }))
        aliases.2.in.dim.names.1.mask = as.logical(sapply(aliases.2, function(name){
            any(name == names(dim.names.1))
        }))
        
        aliases.1.in.dim.names.2 = aliases.1[aliases.1.in.dim.names.2.mask]
        aliases.2.in.dim.names.1 = aliases.1[aliases.2.in.dim.names.1.mask]
        
        # Rename the dimensions in 1 and 2 using the aliases we are going to use
        names(dim.names.1) = replace.with.aliases(names(dim.names.1), aliases=aliases.1.in.dim.names.2)
        names(dim.names.2) = replace.with.aliases(names(dim.names.2), aliases=aliases.2.in.dim.names.1)
        
        # Union the (renamed to aliases) dim.names
        dim.names = union.shared.dim.names(dim.names.1, dim.names.2, specification)
        
        # Figure out which aliases are still 'viable'
        # An alias is viable if the original (un-aliased) name is in the union-ed dim.names
        #   AND the alias is present in both 1 and 2
        viable.aliases.mask = as.logical(sapply(names(aliases.1), function(alias.name){
            any(alias.name==names(dim.names)) &&
                any(alias.name==names(aliases.2)) &&
                all(aliases.1[alias.name]==aliases.2[alias.name])
        }))
        viable.aliases = aliases.1[viable.aliases.mask]
        
        
        # Return
        list(dim.names = dim.names, aliases = viable.aliases)
    }
}
    
replace.with.aliases <- function(values, aliases)
{
    sapply(values, function(v){
        if (any(v==names(aliases)))
            aliases[v]
        else
            v
    })
}

# new names is a character vector
# the names of new.names are the names of the old variables in the expression
# the values of new.names are the values to rename to
rename.expression.vars <- function(expr, new.names)
{
    env = lapply(new.names, function(name){
        parse(text=name)[[1]]
    })
    names(env) = names(new.names)
    
    do.call(substitute,
            list(expr=expr,
                 env=env))
}



substitute.into.vector <- function(values, mapping)
{
    rv = unique(unlist(sapply(values, function(val){
        if (any(val==names(mapping)))
            mapping[[val]]
        else
            val
    })))
    names(rv) = NULL
    rv
}

get.ordinal <- function(nums)
{
    ORDINAL.SUFFIXES = c('th', #0
                         'st', #1
                         'nd', #2,
                         'rd', #3,
                         'th', #4
                         'th', #5
                         'th', #6
                         'th', #7
                         'th', #8
                         'th') #9
    
    last.digits = nums - (10 * floor(nums/10)) + 1
    paste0(nums, ORDINAL.SUFFIXES[last.digits])
}
